<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Tournament Manager</title>
    <style>
        /* --- CSS Variables --- */
        :root {
            --primary-bg: #1a1a2e;
            --secondary-bg: #2e2e4a;
            --accent-color: #e94560;
            --text-color: #e0e0e0;
            --light-text-color: #a0a0a0;
            --border-color: #4a4a6a;
            --hover-bg: #3a3a5a;
            --success-color: #4CAF50;
            --warning-color: #FFC107;
            --error-color: #F44336;
            --info-color: #2196F3;

            --league-primary: #005792; /* EPL inspired */
            --champions-primary: #1a237e; /* UCL inspired */
            --worldcup-primary: #8e24aa; /* WC inspired */

            --header-height: 60px;
            --sidebar-width: 250px;
            --spacing-unit: 16px;
        }

        /* --- Base Styles --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--primary-bg);
            color: var(--text-color);
            display: flex;
            min-height: 100vh;
            overflow-x: hidden;
            font-size: 14px;
        }

        h1, h2, h3, h4, h5, h6 {
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: var(--spacing-unit);
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        button, .btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        button:hover, .btn:hover {
            background-color: #c73a50;
        }

        button:disabled, .btn:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }

        input[type="text"], input[type="number"], input[type="date"], select, textarea {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--light-text-color);
        }

        .form-group {
            margin-bottom: var(--spacing-unit);
        }

        /* --- Layout --- */
        #sidebar {
            width: var(--sidebar-width);
            background-color: var(--secondary-bg);
            padding: var(--spacing-unit);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            z-index: 100;
        }

        #sidebar h2 {
            color: var(--accent-color);
            text-align: center;
            margin-bottom: var(--spacing-unit) * 1.5;
            font-size: 1.5em;
        }

        #sidebar nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #sidebar nav ul li {
            margin-bottom: 5px;
        }

        #sidebar nav ul li a, .sidebar-item {
            display: block;
            padding: 10px 15px;
            color: var(--text-color);
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        #sidebar nav ul li a:hover, .sidebar-item:hover {
            background-color: var(--hover-bg);
            text-decoration: none;
        }

        #sidebar nav ul li a.active, .sidebar-item.active {
            background-color: var(--accent-color);
            color: white;
        }

        .sidebar-section-title {
            color: var(--light-text-color);
            font-size: 0.9em;
            margin-top: var(--spacing-unit);
            margin-bottom: 10px;
            padding: 0 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sidebar-tournament-list {
            max-height: 300px; /* Adjust as needed */
            overflow-y: auto;
            margin-bottom: var(--spacing-unit);
            border-top: 1px solid var(--border-color);
            padding-top: var(--spacing-unit);
        }

        .sidebar-tournament-list .sidebar-item {
            padding-left: 25px;
            font-size: 0.95em;
        }

        #main-content {
            flex-grow: 1;
            padding: var(--spacing-unit) * 1.5;
            overflow-y: auto;
        }

        #tournament-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-unit) * 1.5;
            padding-bottom: var(--spacing-unit);
            border-bottom: 1px solid var(--border-color);
        }

        #tournament-header h1 {
            margin: 0;
            font-size: 2em;
        }

        #tournament-tabs {
            display: flex;
            margin-bottom: var(--spacing-unit);
            border-bottom: 1px solid var(--border-color);
        }

        .tab-button {
            background-color: transparent;
            border: none;
            padding: 10px 20px;
            color: var(--light-text-color);
            cursor: pointer;
            font-size: 1em;
            transition: color 0.2s ease, border-bottom 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px; /* To align with border */
        }

        .tab-button:hover {
            color: var(--text-color);
        }

        .tab-button.active {
            color: var(--accent-color);
            border-bottom: 3px solid var(--accent-color);
        }

        .tab-content {
            display: none;
            padding-top: var(--spacing-unit);
        }

        .tab-content.active {
            display: block;
        }

        /* --- Utility Classes --- */
        .flex-row { display: flex; align-items: center; gap: var(--spacing-unit); }
        .flex-col { display: flex; flex-direction: column; gap: var(--spacing-unit); }
        .justify-between { justify-content: space-between; }
        .align-center { align-items: center; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        .mt-1 { margin-top: var(--spacing-unit); }
        .mb-1 { margin-bottom: var(--spacing-unit); }
        .mb-2 { margin-bottom: var(--spacing-unit) * 2; }
        .p-1 { padding: var(--spacing-unit); }
        .p-2 { padding: var(--spacing-unit) * 2; }
        .card {
            background-color: var(--secondary-bg);
            border-radius: 8px;
            padding: var(--spacing-unit);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            margin-bottom: var(--spacing-unit);
        }
        .grid-2-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-unit);
        }
        .grid-3-col {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-unit);
        }
        .grid-4-col {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-unit);
        }

        /* --- Tables --- */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-unit);
            background-color: var(--secondary-bg);
            border-radius: 8px;
            overflow: hidden;
        }

        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
            background-color: var(--hover-bg);
            color: var(--light-text-color);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .data-table tbody tr:hover {
            background-color: var(--hover-bg);
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .data-table .team-name {
            font-weight: bold;
        }

        .data-table .team-logo-placeholder {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ccc, #888);
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
            border: 1px solid var(--border-color);
        }

        .data-table .sortable {
            cursor: pointer;
            position: relative;
        }

        .data-table .sortable::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid var(--light-text-color);
            opacity: 0.5;
        }

        .data-table .sortable.asc::after {
            border-top: none;
            border-bottom: 4px solid var(--accent-color);
            opacity: 1;
        }

        .data-table .sortable.desc::after {
            border-bottom: none;
            border-top: 4px solid var(--accent-color);
            opacity: 1;
        }

        /* --- Match Fixtures --- */
        .fixture-list .fixture-item {
            background-color: var(--secondary-bg);
            border-radius: 8px;
            padding: 12px var(--spacing-unit);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: 1px solid var(--border-color);
        }

        .fixture-list .fixture-item:hover {
            background-color: var(--hover-bg);
        }

        .fixture-item.played {
            opacity: 0.8;
        }

        .fixture-item .match-info {
            flex-grow: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .fixture-item .team-name {
            font-weight: bold;
            flex-basis: 30%;
            text-align: right;
        }

        .fixture-item .team-name.away {
            text-align: left;
        }

        .fixture-item .score {
            font-weight: bold;
            font-size: 1.1em;
            min-width: 60px;
            text-align: center;
        }

        .fixture-item .vs {
            color: var(--light-text-color);
            font-size: 0.9em;
            min-width: 20px;
            text-align: center;
        }

        .fixture-item .date-time {
            font-size: 0.85em;
            color: var(--light-text-color);
            min-width: 120px;
            text-align: center;
        }

        .fixture-item .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: var(--spacing-unit);
        }

        .status-badge.scheduled { background-color: var(--info-color); color: white; }
        .status-badge.played { background-color: var(--success-color); color: white; }
        .status-badge.postponed { background-color: var(--warning-color); color: #333; }

        /* --- Group Stage Cards --- */
        .group-card {
            background-color: var(--secondary-bg);
            border-radius: 8px;
            padding: var(--spacing-unit);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .group-card h3 {
            margin-top: 0;
            margin-bottom: var(--spacing-unit);
            color: var(--accent-color);
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .group-card .data-table {
            margin-bottom: 0;
        }

        /* --- Knockout Bracket --- */
        .knockout-bracket {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-unit);
            overflow-x: auto;
        }

        .knockout-round {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: var(--spacing-unit) * 2;
            position: relative;
            width: 100%;
        }

        .knockout-round-title {
            font-size: 1.5em;
            color: var(--accent-color);
            margin-bottom: var(--spacing-unit);
            text-align: center;
            width: 100%;
        }

        .knockout-matches {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit);
            width: 100%;
            max-width: 800px; /* Limit width for readability */
        }

        .knockout-match-container {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
        }

        .knockout-match {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            max-width: 300px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
            z-index: 1;
        }

        .knockout-match:hover {
            background-color: var(--hover-bg);
        }

        .knockout-match .team-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .knockout-match .team-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .knockout-match .score {
            min-width: 30px;
            text-align: right;
        }

        .knockout-match .aggregate-score {
            font-size: 0.8em;
            color: var(--light-text-color);
            text-align: center;
            margin-top: 5px;
            border-top: 1px dashed var(--border-color);
            padding-top: 5px;
        }

        .knockout-match.winner .team-line {
            color: var(--accent-color);
        }

        /* Bracket lines */
        .bracket-line {
            position: absolute;
            background-color: var(--border-color);
            z-index: 0;
        }

        /* Vertical line connecting matches in a round */
        .bracket-line.vertical {
            width: 2px;
            height: calc(100% + var(--spacing-unit)); /* Connects center of matches */
            left: 50%;
            transform: translateX(-50%);
            top: calc(-0.5 * var(--spacing-unit));
        }

        /* Horizontal line connecting to next round */
        .bracket-line.horizontal {
            height: 2px;
            width: calc(var(--spacing-unit) * 2); /* Length of horizontal line */
            right: -calc(var(--spacing-unit) * 2);
            top: 50%;
            transform: translateY(-50%);
        }

        /* Arrow for advancing team */
        .bracket-arrow {
            position: absolute;
            right: -20px; /* Position relative to match */
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid var(--accent-color);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2;
        }

        .knockout-match.winner + .bracket-arrow {
            opacity: 1;
        }

        /* Specific styling for World Cup single elimination */
        .worldcup-bracket .knockout-match-container {
            position: relative;
            margin-bottom: var(--spacing-unit);
        }

        .worldcup-bracket .knockout-match-container::before {
            content: '';
            position: absolute;
            left: -20px; /* Adjust as needed */
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: var(--border-color);
            z-index: 0;
        }

        .worldcup-bracket .knockout-match-container:nth-child(odd)::before {
            height: calc(100% + var(--spacing-unit));
            top: 0;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }

        .worldcup-bracket .knockout-match-container:nth-child(even)::before {
            height: calc(100% + var(--spacing-unit));
            top: calc(-100% - var(--spacing-unit));
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }

        .worldcup-bracket .knockout-match-container:nth-child(odd) .knockout-match {
            margin-left: 20px;
        }
        .worldcup-bracket .knockout-match-container:nth-child(even) .knockout-match {
            margin-left: 20px;
        }

        .worldcup-bracket .knockout-match-container:nth-child(odd) .knockout-match::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 2px;
            background-color: var(--border-color);
            z-index: 0;
        }

        .worldcup-bracket .knockout-match-container:nth-child(even) .knockout-match::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 2px;
            background-color: var(--border-color);
            z-index: 0;
        }

        .worldcup-bracket .knockout-round {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: auto;
            margin-right: var(--spacing-unit) * 4; /* Space for lines */
        }

        .worldcup-bracket .knockout-round:last-child {
            margin-right: 0;
        }

        .worldcup-bracket .knockout-rounds-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: var(--spacing-unit) * 4;
            padding: var(--spacing-unit);
            overflow-x: auto;
            width: 100%;
        }

        .worldcup-bracket .knockout-match {
            width: 250px; /* Fixed width for WC matches */
        }

        .worldcup-bracket .knockout-match-container {
            margin-bottom: var(--spacing-unit);
            position: relative;
        }

        .worldcup-bracket .knockout-match-container .bracket-connector {
            position: absolute;
            left: -20px;
            width: 20px;
            height: 2px;
            background-color: var(--border-color);
            top: 50%;
            transform: translateY(-50%);
        }

        .worldcup-bracket .knockout-match-container.has-next-match .bracket-connector-vertical {
            position: absolute;
            left: -20px;
            width: 2px;
            background-color: var(--border-color);
            z-index: 0;
        }

        .worldcup-bracket .knockout-match-container.has-next-match:nth-child(odd) .bracket-connector-vertical {
            top: 50%;
            height: calc(50% + var(--spacing-unit) / 2 + 1px); /* Connects to center of next match */
            border-bottom-left-radius: 2px;
        }

        .worldcup-bracket .knockout-match-container.has-next-match:nth-child(even) .bracket-connector-vertical {
            bottom: 50%;
            height: calc(50% + var(--spacing-unit) / 2 + 1px);
            border-top-left-radius: 2px;
        }

        .worldcup-bracket .knockout-match-container.has-next-match .bracket-connector-horizontal-next {
            position: absolute;
            left: -20px - (var(--spacing-unit) * 2); /* Adjust based on gap */
            width: var(--spacing-unit) * 2;
            height: 2px;
            background-color: var(--border-color);
            top: 50%;
            transform: translateY(-50%);
            z-index: 0;
        }

        .worldcup-bracket .knockout-match-container.has-next-match .bracket-arrow {
            left: -20px - (var(--spacing-unit) * 2) - 6px; /* Arrow position */
            right: auto;
            transform: translateY(-50%) rotate(180deg);
            border-left: none;
            border-right: 6px solid var(--accent-color);
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--primary-bg);
            padding: var(--spacing-unit) * 1.5;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-unit);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--accent-color);
        }

        .modal-close-btn {
            background: none;
            border: none;
            color: var(--light-text-color);
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
        }

        .modal-close-btn:hover {
            color: var(--text-color);
        }

        .modal-footer {
            margin-top: var(--spacing-unit);
            padding-top: var(--spacing-unit);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-unit);
        }

        /* Match Modal Specific */
        .match-modal-teams {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: var(--spacing-unit);
            font-size: 1.2em;
        }

        .match-modal-teams .team-name {
            font-weight: bold;
            color: var(--text-color);
        }

        .match-modal-teams .score-input {
            width: 60px;
            text-align: center;
            font-size: 1.5em;
            padding: 5px;
            background-color: var(--hover-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        .match-events-section {
            margin-top: var(--spacing-unit);
            border-top: 1px solid var(--border-color);
            padding-top: var(--spacing-unit);
        }

        .match-events-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            margin-bottom: var(--spacing-unit);
        }

        .match-events-list li {
            padding: 8px 12px;
            border-bottom: 1px dashed var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .match-events-list li:last-child {
            border-bottom: none;
        }

        .match-events-list li .event-details {
            flex-grow: 1;
        }

        .match-events-list li .event-actions button {
            background: none;
            border: none;
            color: var(--error-color);
            font-size: 1em;
            cursor: pointer;
            padding: 5px;
        }

        .match-events-list li .event-actions button:hover {
            color: #ff7878;
        }

        .event-type-goal { color: var(--success-color); }
        .event-type-assist { color: var(--info-color); }
        .event-type-yellow { color: var(--warning-color); }
        .event-type-red { color: var(--error-color); }

        .player-select-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-select-group select {
            flex-grow: 1;
        }

        .player-select-group input[type="number"] {
            width: 60px;
            flex-shrink: 0;
        }

        /* Player Stats */
        .player-stats-leaderboard {
            margin-bottom: var(--spacing-unit);
        }

        .player-stats-leaderboard h3 {
            color: var(--info-color);
            margin-bottom: var(--spacing-unit);
        }

        .player-stats-leaderboard .data-table th:first-child,
        .player-stats-leaderboard .data-table td:first-child {
            width: 30px;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #sidebar {
                width: 100%;
                height: auto;
                position: relative;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
                padding-bottom: 0;
            }

            #sidebar h2 {
                margin-bottom: var(--spacing-unit);
            }

            #sidebar nav ul {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 5px;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: var(--spacing-unit);
            }

            #sidebar nav ul li {
                margin-bottom: 0;
            }

            #sidebar nav ul li a, .sidebar-item {
                padding: 8px 12px;
                font-size: 0.9em;
            }

            .sidebar-section-title {
                display: none; /* Hide section titles on small screens */
            }

            .sidebar-tournament-list {
                max-height: 150px;
                border-top: none;
                padding-top: 0;
                margin-bottom: var(--spacing-unit);
            }

            #main-content {
                padding: var(--spacing-unit);
            }

            #tournament-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-unit);
            }

            #tournament-header h1 {
                font-size: 1.5em;
            }

            #tournament-tabs {
                overflow-x: auto;
                white-space: nowrap;
                justify-content: initial;
            }

            .tab-button {
                flex-shrink: 0;
            }

            .grid-2-col, .grid-3-col, .grid-4-col {
                grid-template-columns: 1fr;
            }

            .fixture-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .fixture-item .match-info {
                flex-direction: row;
                width: 100%;
                justify-content: space-between;
            }

            .fixture-item .team-name {
                text-align: left;
                flex-basis: auto;
            }

            .fixture-item .team-name.away {
                text-align: right;
            }

            .fixture-item .date-time {
                width: 100%;
                text-align: left;
            }

            .fixture-item .status-badge {
                margin-left: 0;
                margin-top: 5px;
            }

            .knockout-bracket {
                padding: var(--spacing-unit) 0;
            }

            .knockout-round {
                width: 100%;
                margin-bottom: var(--spacing-unit);
            }

            .knockout-match {
                max-width: none;
            }

            .worldcup-bracket .knockout-rounds-wrapper {
                flex-direction: column;
                gap: var(--spacing-unit);
            }

            .worldcup-bracket .knockout-round {
                width: 100%;
                align-items: center;
                margin-right: 0;
            }

            .worldcup-bracket .knockout-match {
                width: 100%;
                margin-left: 0;
            }

            .worldcup-bracket .knockout-match-container::before,
            .worldcup-bracket .knockout-match-container .bracket-connector,
            .worldcup-bracket .knockout-match-container .bracket-connector-vertical,
            .worldcup-bracket .knockout-match-container .bracket-connector-horizontal-next,
            .worldcup-bracket .knockout-match-container .bracket-arrow,
            .worldcup-bracket .knockout-match-container:nth-child(odd) .knockout-match::after,
            .worldcup-bracket .knockout-match-container:nth-child(even) .knockout-match::after {
                display: none; /* Hide complex bracket lines on small screens */
            }
        }
    </style>
</head>
<body>
    <aside id="sidebar">
        <h2>Tournament Manager</h2>
        <nav>
            <ul>
                <li><a href="#" class="sidebar-item" data-view="home">Home</a></li>
                <li><a href="#" class="sidebar-item" data-view="create-tournament">Create New Tournament</a></li>
            </ul>
            <div class="sidebar-section-title">Tournament Modes</div>
            <ul>
                <li><a href="#" class="sidebar-item" data-mode="league">League</a></li>
                <li><a href="#" class="sidebar-item" data-mode="champions">Champions League</a></li>
                <li><a href="#" class="sidebar-item" data-mode="worldcup">World Cup</a></li>
            </ul>
            <div class="sidebar-section-title">Your Tournaments</div>
            <ul id="tournament-list" class="sidebar-tournament-list">
                <!-- Tournament items will be rendered here -->
            </ul>
            <div class="sidebar-section-title">Data Management</div>
            <ul>
                <li><a href="#" class="sidebar-item" id="export-data-btn">Export All Data</a></li>
                <li><a href="#" class="sidebar-item" id="import-data-btn">Import Data</a></li>
                <li><a href="#" class="sidebar-item" id="seed-demo-data-btn">Seed Demo Data</a></li>
            </ul>
        </nav>
    </aside>

    <main id="main-content">
        <div id="home-view" class="tab-content active">
            <h1>Welcome to the Football Tournament Manager!</h1>
            <p>Select a tournament mode from the sidebar or create a new tournament to get started.</p>
            <div class="grid-3-col mt-2">
                <div class="card">
                    <h3>League Mode</h3>
                    <p>Manage a domestic league season with round-robin fixtures, standings, and player stats.</p>
                    <button onclick="app.ui.showCreateTournamentModal('league')">Create League</button>
                </div>
                <div class="card">
                    <h3>Champions League Mode</h3>
                    <p>Organize a group stage followed by a knockout bracket, inspired by European club competitions.</p>
                    <button onclick="app.ui.showCreateTournamentModal('champions')">Create Champions League</button>
                </div>
                <div class="card">
                    <h3>World Cup Mode</h3>
                    <p>Run a global tournament with group stages and a single-elimination knockout bracket.</p>
                    <button onclick="app.ui.showCreateTournamentModal('worldcup')">Create World Cup</button>
                </div>
            </div>
        </div>

        <div id="create-tournament-view" class="tab-content">
            <h1>Create New Tournament</h1>
            <div class="card">
                <div class="form-group">
                    <label for="new-tournament-name">Tournament Name:</label>
                    <input type="text" id="new-tournament-name" placeholder="e.g., Premier League 2024/25">
                </div>
                <div class="form-group">
                    <label for="new-tournament-mode">Tournament Mode:</label>
                    <select id="new-tournament-mode">
                        <option value="league">League (Season)</option>
                        <option value="champions">Champions League</option>
                        <option value="worldcup">World Cup</option>
                    </select>
                </div>
                <button id="create-tournament-btn">Create Tournament</button>
            </div>
        </div>

        <div id="tournament-view" class="tab-content">
            <div id="tournament-header">
                <h1 id="current-tournament-name"></h1>
                <div id="tournament-actions">
                    <!-- Actions like "Generate Fixtures" will go here -->
                </div>
            </div>

            <div id="tournament-tabs">
                <button class="tab-button active" data-tab="overview">Overview</button>
                <button class="tab-button" data-tab="fixtures">Fixtures</button>
                <button class="tab-button" data-tab="standings">Standings</button>
                <button class="tab-button" data-tab="player-stats">Player Stats</button>
                <button class="tab-button" data-tab="knockout">Knockout</button>
                <button class="tab-button" data-tab="manage">Manage</button>
            </div>

            <div id="overview-tab" class="tab-content active">
                <div class="card">
                    <h3>Tournament Summary</h3>
                    <p><strong>Mode:</strong> <span id="overview-mode"></span></p>
                    <p><strong>Teams:</strong> <span id="overview-num-teams"></span></p>
                    <p><strong>Matches Played:</strong> <span id="overview-matches-played"></span> / <span id="overview-total-matches"></span></p>
                    <p><strong>Status:</strong> <span id="overview-status"></span></p>
                </div>
                <div id="overview-next-fixtures" class="card">
                    <h3>Upcoming Fixtures</h3>
                    <div class="fixture-list">
                        <!-- Next fixtures will be loaded here -->
                    </div>
                </div>
            </div>

            <div id="fixtures-tab" class="tab-content">
                <h2>Fixtures</h2>
                <div class="flex-row justify-between mb-1">
                    <div class="form-group" style="flex-grow: 1; margin-bottom: 0;">
                        <label for="fixture-team-filter">Filter by Team:</label>
                        <select id="fixture-team-filter">
                            <option value="">All Teams</option>
                        </select>
                    </div>
                    <button id="simulate-all-fixtures-btn" class="btn">Simulate All Remaining</button>
                </div>
                <div id="fixtures-list" class="fixture-list">
                    <!-- Fixtures will be loaded here -->
                </div>
            </div>

            <div id="standings-tab" class="tab-content">
                <h2>Standings</h2>
                <div id="standings-container">
                    <!-- Standings tables will be loaded here -->
                </div>
                <button id="export-standings-csv-btn" class="btn mt-1">Export Standings as CSV</button>
            </div>

            <div id="player-stats-tab" class="tab-content">
                <h2>Player Statistics</h2>
                <div class="flex-row mb-1">
                    <div class="form-group" style="flex-grow: 1; margin-bottom: 0;">
                        <label for="player-stats-team-filter">Filter by Team:</label>
                        <select id="player-stats-team-filter">
                            <option value="">All Teams</option>
                        </select>
                    </div>
                </div>
                <div class="grid-2-col">
                    <div class="player-stats-leaderboard card">
                        <h3>Top Scorers</h3>
                        <table class="data-table" id="top-scorers-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th class="text-right">Goals</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="player-stats-leaderboard card">
                        <h3>Top Assists</h3>
                        <table class="data-table" id="top-assists-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th class="text-right">Assists</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="player-stats-leaderboard card">
                        <h3>Most Yellow Cards</h3>
                        <table class="data-table" id="top-yellow-cards-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th class="text-right">Yellow</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div class="player-stats-leaderboard card">
                        <h3>Most Red Cards</h3>
                        <table class="data-table" id="top-red-cards-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th class="text-right">Red</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </div>
                    </div>
                </div>
            </div>

            <div id="knockout-tab" class="tab-content">
                <h2>Knockout Stage</h2>
                <div id="knockout-bracket-container">
                    <!-- Knockout bracket will be rendered here -->
                </div>
            </div>

            <div id="manage-tab" class="tab-content">
                <h2>Manage Tournament</h2>
                <div class="card mb-2">
                    <h3>Tournament Settings</h3>
                    <div id="tournament-settings-form">
                        <!-- Mode-specific settings will be loaded here -->
                    </div>
                    <button id="save-tournament-settings-btn" class="btn mt-1">Save Settings</button>
                </div>

                <div class="card mb-2">
                    <h3>Teams</h3>
                    <div id="team-list-container">
                        <table class="data-table" id="manage-teams-table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Short Name</th>
                                    <th>Country</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Teams will be listed here -->
                            </tbody>
                        </table>
                    </div>
                    <button id="add-team-btn" class="btn mt-1">Add Team</button>
                    <button id="draw-groups-btn" class="btn mt-1" style="display: none;">Draw Groups</button>
                    <button id="generate-fixtures-btn" class="btn mt-1" style="display: none;">Generate Fixtures</button>
                </div>

                <div class="card">
                    <h3>Danger Zone</h3>
                    <button id="reset-tournament-btn" class="btn" style="background-color: var(--error-color);">Reset This Tournament</button>
                </div>
            </div>
        </div>
    </main>

    <!-- Modals -->
    <div id="match-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="match-modal-title">Match Details</h2>
                <button class="modal-close-btn" data-close-modal="match-modal">&times;</button>
            </div>
            <div class="modal-body">
                <p class="text-center" id="match-modal-date"></p>
                <div class="match-modal-teams">
                    <span id="match-modal-home-team" class="team-name"></span>
                    <input type="number" id="match-modal-home-score" class="score-input" min="0" value="0">
                    <span class="vs">-</span>
                    <input type="number" id="match-modal-away-score" class="score-input" min="0" value="0">
                    <span id="match-modal-away-team" class="team-name"></span>
                </div>
                <div class="flex-row justify-center mb-1">
                    <button id="match-modal-simulate-btn" class="btn">Simulate Score</button>
                    <button id="match-modal-extra-time-btn" class="btn" style="display: none;">Add Extra Time</button>
                    <button id="match-modal-penalties-btn" class="btn" style="display: none;">Add Penalties</button>
                </div>

                <div id="match-modal-extra-time-section" style="display: none;">
                    <h4>Extra Time</h4>
                    <div class="match-modal-teams">
                        <span id="match-modal-home-team-et" class="team-name"></span>
                        <input type="number" id="match-modal-home-score-et" class="score-input" min="0" value="0">
                        <span class="vs">-</span>
                        <input type="number" id="match-modal-away-score-et" class="score-input" min="0" value="0">
                        <span id="match-modal-away-team-et" class="team-name"></span>
                    </div>
                </div>

                <div id="match-modal-penalties-section" style="display: none;">
                    <h4>Penalties</h4>
                    <div class="match-modal-teams">
                        <span id="match-modal-home-team-pen" class="team-name"></span>
                        <input type="number" id="match-modal-home-score-pen" class="score-input" min="0" value="0">
                        <span class="vs">-</span>
                        <input type="number" id="match-modal-away-score-pen" class="score-input" min="0" value="0">
                        <span id="match-modal-away-team-pen" class="team-name"></span>
                    </div>
                </div>

                <div class="match-events-section">
                    <h4>Match Events</h4>
                    <ul id="match-modal-events-list" class="match-events-list">
                        <!-- Events will be listed here -->
                    </ul>
                    <div class="flex-row gap-1">
                        <div class="form-group" style="flex-grow: 1;">
                            <label for="event-type">Event Type:</label>
                            <select id="event-type">
                                <option value="goal">Goal</option>
                                <option value="assist">Assist</option>
                                <option value="yellow">Yellow Card</option>
                                <option value="red">Red Card</option>
                            </select>
                        </div>
                        <div class="form-group" style="flex-grow: 1;">
                            <label for="event-minute">Minute:</label>
                            <input type="number" id="event-minute" min="1" value="1">
                        </div>
                    </div>
                    <div class="player-select-group">
                        <div class="form-group" style="flex-grow: 1;">
                            <label for="event-player-team">Team:</label>
                            <select id="event-player-team">
                                <!-- Teams will be loaded here -->
                            </select>
                        </div>
                        <div class="form-group" style="flex-grow: 2;">
                            <label for="event-player">Player:</label>
                            <select id="event-player">
                                <!-- Players will be loaded here -->
                            </select>
                        </div>
                        <div class="form-group" style="flex-grow: 2;" id="event-assist-player-group">
                            <label for="event-assist-player">Assisted By:</label>
                            <select id="event-assist-player">
                                <option value="">None</option>
                                <!-- Players will be loaded here -->
                            </select>
                        </div>
                    </div>
                    <button id="add-event-btn" class="btn">Add Event</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" data-close-modal="match-modal">Cancel</button>
                <button id="match-modal-save-btn" class="btn">Save Result</button>
            </div>
        </div>
    </div>

    <div id="team-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="team-modal-title">Add/Edit Team</h2>
                <button class="modal-close-btn" data-close-modal="team-modal">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="team-modal-id">
                <div class="form-group">
                    <label for="team-name">Team Name:</label>
                    <input type="text" id="team-name" required>
                </div>
                <div class="form-group">
                    <label for="team-short-name">Short Name (e.g., MUN):</label>
                    <input type="text" id="team-short-name" maxlength="3">
                </div>
                <div class="form-group">
                    <label for="team-country">Country:</label>
                    <input type="text" id="team-country">
                </div>
                <div class="form-group">
                    <label for="team-primary-color">Primary Color:</label>
                    <input type="color" id="team-primary-color" value="#005792">
                </div>
                <div class="form-group">
                    <label for="team-secondary-color">Secondary Color:</label>
                    <input type="color" id="team-secondary-color" value="#FFFFFF">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" data-close-modal="team-modal">Cancel</button>
                <button id="team-modal-save-btn" class="btn">Save Team</button>
            </div>
        </div>
    </div>

    <div id="player-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="player-modal-title">Manage Players for <span id="player-modal-team-name"></span></h2>
                <button class="modal-close-btn" data-close-modal="player-modal">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="player-modal-team-id">
                <h3>Current Players</h3>
                <table class="data-table" id="manage-players-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Name</th>
                            <th>Position</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Players will be listed here -->
                    </tbody>
                </table>
                <h3 class="mt-1">Add New Player</h3>
                <input type="hidden" id="edit-player-id">
                <div class="form-group">
                    <label for="player-name">Player Name:</label>
                    <input type="text" id="player-name" required>
                </div>
                <div class="form-group">
                    <label for="player-number">Shirt Number:</label>
                    <input type="number" id="player-number" min="1" max="99">
                </div>
                <div class="form-group">
                    <label for="player-position">Position:</label>
                    <input type="text" id="player-position" placeholder="e.g., FW, MF, DF, GK">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" data-close-modal="player-modal">Done</button>
                <button id="player-modal-add-edit-btn" class="btn">Add Player</button>
            </div>
        </div>
    </div>

    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <script>
        const app = {}; // Global application object

        // --- Data Management ---
        app.data = {
            localStorageKey: 'football_manager_v1',
            state: {
                tournaments: [],
                teams: {}, // { teamId: { id, name, ... }, ... }
                players: {}, // { teamId: [{ id, name, ... }], ... }
                fixtures: {}, // { tournamentId: [{ id, date, ... }], ... }
                standings: {}, // { tournamentId: { groupId: [{ teamId, P, W, ... }] }, ... }
                knockout: {}, // { tournamentId: { rounds: [...] }, ... }
            },
            currentTournamentId: null,
            uniqueIdCounter: 0,

            generateUniqueId() {
                return `id_${Date.now()}_${app.data.uniqueIdCounter++}`;
            },

            saveState() {
                localStorage.setItem(app.data.localStorageKey, JSON.stringify(app.data.state));
                console.log('State saved to localStorage.');
            },

            loadState() {
                const savedState = localStorage.getItem(app.data.localStorageKey);
                if (savedState) {
                    app.data.state = JSON.parse(savedState);
                    // Re-initialize uniqueIdCounter to avoid collisions
                    let maxIdNum = 0;
                    const allIds = [
                        ...app.data.state.tournaments.map(t => t.id),
                        ...Object.keys(app.data.state.teams),
                        ...Object.values(app.data.state.players).flat().map(p => p.id),
                        ...Object.values(app.data.state.fixtures).flat().map(f => f.id)
                    ];
                    allIds.forEach(id => {
                        const match = id.match(/_(\d+)_(\d+)$/);
                        if (match) {
                            maxIdNum = Math.max(maxIdNum, parseInt(match[1]), parseInt(match[2]));
                        }
                    });
                    app.data.uniqueIdCounter = maxIdNum + 1;
                    console.log('State loaded from localStorage.');
                    return true;
                }
                console.log('No state found in localStorage.');
                return false;
            },

            resetTournament(tournamentId) {
                const tournamentIndex = app.data.state.tournaments.findIndex(t => t.id === tournamentId);
                if (tournamentIndex !== -1) {
                    const tournament = app.data.state.tournaments[tournamentIndex];
                    // Remove associated fixtures, standings, knockout, and players
                    delete app.data.state.fixtures[tournamentId];
                    delete app.data.state.standings[tournamentId];
                    delete app.data.state.knockout[tournamentId];
                    // Remove players for teams in this tournament
                    tournament.teams.forEach(teamId => {
                        delete app.data.state.players[teamId];
                    });
                    // Remove teams themselves
                    tournament.teams.forEach(teamId => {
                        delete app.data.state.teams[teamId];
                    });
                    // Remove the tournament itself
                    app.data.state.tournaments.splice(tournamentIndex, 1);

                    app.data.saveState();
                    app.ui.renderSidebar();
                    app.ui.showHomeView();
                    alert(`Tournament "${tournament.name}" has been reset and removed.`);
                }
            },

            exportState() {
                const dataStr = JSON.stringify(app.data.state, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `football_manager_data_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },

            importState(jsonString) {
                try {
                    const importedState = JSON.parse(jsonString);
                    // Basic validation
                    if (importedState && Array.isArray(importedState.tournaments) && typeof importedState.teams === 'object') {
                        app.data.state = importedState;
                        app.data.saveState();
                        app.ui.renderSidebar();
                        app.ui.showHomeView();
                        alert('Data imported successfully!');
                    } else {
                        throw new Error('Invalid data structure.');
                    }
                } catch (e) {
                    alert('Failed to import data: ' + e.message);
                    console.error('Import error:', e);
                }
            },

            // --- Tournament Data Accessors ---
            getTournament(id) {
                return app.data.state.tournaments.find(t => t.id === id);
            },
            getTeamsInTournament(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return [];
                return tournament.teams.map(teamId => app.data.state.teams[teamId]).filter(Boolean);
            },
            getTeam(teamId) {
                return app.data.state.teams[teamId];
            },
            getPlayersInTeam(teamId) {
                return app.data.state.players[teamId] || [];
            },
            getPlayer(teamId, playerId) {
                return (app.data.state.players[teamId] || []).find(p => p.id === playerId);
            },
            getFixtures(tournamentId) {
                return app.data.state.fixtures[tournamentId] || [];
            },
            getFixture(tournamentId, fixtureId) {
                return (app.data.state.fixtures[tournamentId] || []).find(f => f.id === fixtureId);
            },
            getStandings(tournamentId, groupId = null) {
                if (!app.data.state.standings[tournamentId]) return [];
                if (groupId) {
                    return app.data.state.standings[tournamentId][groupId] || [];
                }
                // For league mode, there's no group, so return the main standings array
                return app.data.state.standings[tournamentId].main || [];
            },
            getKnockout(tournamentId) {
                return app.data.state.knockout[tournamentId];
            }
        };

        // --- UI Management ---
        app.ui = {
            elements: {
                sidebar: document.getElementById('sidebar'),
                mainContent: document.getElementById('main-content'),
                tournamentList: document.getElementById('tournament-list'),
                homeView: document.getElementById('home-view'),
                createTournamentView: document.getElementById('create-tournament-view'),
                tournamentView: document.getElementById('tournament-view'),
                currentTournamentName: document.getElementById('current-tournament-name'),
                tournamentActions: document.getElementById('tournament-actions'),
                tournamentTabs: document.getElementById('tournament-tabs'),
                overviewTab: document.getElementById('overview-tab'),
                fixturesTab: document.getElementById('fixtures-tab'),
                standingsTab: document.getElementById('standings-tab'),
                playerStatsTab: document.getElementById('player-stats-tab'),
                knockoutTab: document.getElementById('knockout-tab'),
                manageTab: document.getElementById('manage-tab'),

                // Create Tournament
                newTournamentName: document.getElementById('new-tournament-name'),
                newTournamentMode: document.getElementById('new-tournament-mode'),
                createTournamentBtn: document.getElementById('create-tournament-btn'),

                // Overview
                overviewMode: document.getElementById('overview-mode'),
                overviewNumTeams: document.getElementById('overview-num-teams'),
                overviewMatchesPlayed: document.getElementById('overview-matches-played'),
                overviewTotalMatches: document.getElementById('overview-total-matches'),
                overviewStatus: document.getElementById('overview-status'),
                overviewNextFixtures: document.querySelector('#overview-next-fixtures .fixture-list'),

                // Fixtures
                fixtureTeamFilter: document.getElementById('fixture-team-filter'),
                fixturesList: document.getElementById('fixtures-list'),
                simulateAllFixturesBtn: document.getElementById('simulate-all-fixtures-btn'),

                // Standings
                standingsContainer: document.getElementById('standings-container'),
                exportStandingsCsvBtn: document.getElementById('export-standings-csv-btn'),

                // Player Stats
                playerStatsTeamFilter: document.getElementById('player-stats-team-filter'),
                topScorersTable: document.getElementById('top-scorers-table').querySelector('tbody'),
                topAssistsTable: document.getElementById('top-assists-table').querySelector('tbody'),
                topYellowCardsTable: document.getElementById('top-yellow-cards-table').querySelector('tbody'),
                topRedCardsTable: document.getElementById('top-red-cards-table').querySelector('tbody'),

                // Knockout
                knockoutBracketContainer: document.getElementById('knockout-bracket-container'),

                // Manage
                tournamentSettingsForm: document.getElementById('tournament-settings-form'),
                saveTournamentSettingsBtn: document.getElementById('save-tournament-settings-btn'),
                manageTeamsTable: document.getElementById('manage-teams-table').querySelector('tbody'),
                addTeamBtn: document.getElementById('add-team-btn'),
                drawGroupsBtn: document.getElementById('draw-groups-btn'),
                generateFixturesBtn: document.getElementById('generate-fixtures-btn'),
                resetTournamentBtn: document.getElementById('reset-tournament-btn'),

                // Modals
                matchModal: document.getElementById('match-modal'),
                matchModalTitle: document.getElementById('match-modal-title'),
                matchModalDate: document.getElementById('match-modal-date'),
                matchModalHomeTeam: document.getElementById('match-modal-home-team'),
                matchModalHomeScore: document.getElementById('match-modal-home-score'),
                matchModalAwayScore: document.getElementById('match-modal-away-score'),
                matchModalAwayTeam: document.getElementById('match-modal-away-team'),
                matchModalSimulateBtn: document.getElementById('match-modal-simulate-btn'),
                matchModalExtraTimeBtn: document.getElementById('match-modal-extra-time-btn'),
                matchModalPenaltiesBtn: document.getElementById('match-modal-penalties-btn'),
                matchModalExtraTimeSection: document.getElementById('match-modal-extra-time-section'),
                matchModalHomeScoreET: document.getElementById('match-modal-home-score-et'),
                matchModalAwayScoreET: document.getElementById('match-modal-away-score-et'),
                matchModalPenaltiesSection: document.getElementById('match-modal-penalties-section'),
                matchModalHomeScorePen: document.getElementById('match-modal-home-score-pen'),
                matchModalAwayScorePen: document.getElementById('match-modal-away-score-pen'),
                matchModalEventsList: document.getElementById('match-modal-events-list'),
                eventType: document.getElementById('event-type'),
                eventMinute: document.getElementById('event-minute'),
                eventPlayerTeam: document.getElementById('event-player-team'),
                eventPlayer: document.getElementById('event-player'),
                eventAssistPlayerGroup: document.getElementById('event-assist-player-group'),
                eventAssistPlayer: document.getElementById('event-assist-player'),
                addEventBtn: document.getElementById('add-event-btn'),
                matchModalSaveBtn: document.getElementById('match-modal-save-btn'),

                teamModal: document.getElementById('team-modal'),
                teamModalTitle: document.getElementById('team-modal-title'),
                teamModalId: document.getElementById('team-modal-id'),
                teamName: document.getElementById('team-name'),
                teamShortName: document.getElementById('team-short-name'),
                teamCountry: document.getElementById('team-country'),
                teamPrimaryColor: document.getElementById('team-primary-color'),
                teamSecondaryColor: document.getElementById('team-secondary-color'),
                teamModalSaveBtn: document.getElementById('team-modal-save-btn'),

                playerModal: document.getElementById('player-modal'),
                playerModalTeamName: document.getElementById('player-modal-team-name'),
                playerModalTeamId: document.getElementById('player-modal-team-id'),
                managePlayersTable: document.getElementById('manage-players-table').querySelector('tbody'),
                editPlayerId: document.getElementById('edit-player-id'),
                playerName: document.getElementById('player-name'),
                playerNumber: document.getElementById('player-number'),
                playerPosition: document.getElementById('player-position'),
                playerModalAddEditBtn: document.getElementById('player-modal-add-edit-btn'),

                importFileInput: document.getElementById('import-file-input'),
                exportDataBtn: document.getElementById('export-data-btn'),
                importDataBtn: document.getElementById('import-data-btn'),
                seedDemoDataBtn: document.getElementById('seed-demo-data-btn'),
            },
            currentActiveTab: 'overview',
            currentMatchFixtureId: null, // Used for match modal context
            currentTeamIdForPlayers: null, // Used for player modal context

            init() {
                this.bindGlobalEventListeners();
            },

            bindGlobalEventListeners() {
                // Sidebar navigation
                this.elements.sidebar.addEventListener('click', (e) => {
                    const target = e.target.closest('.sidebar-item');
                    if (!target) return;

                    // Remove active class from all sidebar items
                    document.querySelectorAll('.sidebar-item').forEach(item => item.classList.remove('active'));
                    target.classList.add('active');

                    if (target.dataset.view === 'home') {
                        this.showHomeView();
                    } else if (target.dataset.view === 'create-tournament') {
                        this.showCreateTournamentModal();
                    } else if (target.dataset.mode) {
                        this.showCreateTournamentModal(target.dataset.mode);
                    } else if (target.dataset.tournamentId) {
                        app.data.currentTournamentId = target.dataset.tournamentId;
                        this.showTournamentView();
                    } else if (target.id === 'export-data-btn') {
                        app.data.exportState();
                    } else if (target.id === 'import-data-btn') {
                        this.elements.importFileInput.click();
                    } else if (target.id === 'seed-demo-data-btn') {
                        app.logic.seedDemoData();
                        this.renderSidebar();
                        this.showHomeView();
                    }
                });

                // Tournament tabs
                this.elements.tournamentTabs.addEventListener('click', (e) => {
                    const target = e.target.closest('.tab-button');
                    if (!target) return;

                    document.querySelectorAll('#tournament-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                    target.classList.add('active');

                    document.querySelectorAll('#tournament-view .tab-content').forEach(content => content.classList.remove('active'));
                    const tabId = target.dataset.tab;
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                    this.currentActiveTab = tabId;
                    this.renderCurrentTournamentView(); // Re-render content for the active tab
                });

                // Create Tournament button
                this.elements.createTournamentBtn.addEventListener('click', () => {
                    const name = this.elements.newTournamentName.value.trim();
                    const mode = this.elements.newTournamentMode.value;
                    if (name) {
                        app.logic.createTournament(name, mode);
                        this.elements.newTournamentName.value = '';
                        this.renderSidebar();
                        this.showTournamentView(app.data.state.tournaments[app.data.state.tournaments.length - 1].id);
                    } else {
                        alert('Please enter a tournament name.');
                    }
                });

                // Match Modal close buttons
                document.querySelectorAll('.modal-close-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const modalId = e.target.dataset.closeModal;
                        document.getElementById(modalId).classList.remove('active');
                    });
                });
                document.querySelectorAll('.modal-overlay').forEach(overlay => {
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            overlay.classList.remove('active');
                        }
                    });
                });

                // Match Modal event listeners
                this.elements.matchModalSimulateBtn.addEventListener('click', () => this.simulateMatchInModal());
                this.elements.matchModalExtraTimeBtn.addEventListener('click', () => this.toggleExtraTimeInput(true));
                this.elements.matchModalPenaltiesBtn.addEventListener('click', () => this.togglePenaltiesInput(true));
                this.elements.eventPlayerTeam.addEventListener('change', () => this.populatePlayerSelect(this.elements.eventPlayerTeam.value, this.elements.eventPlayer));
                this.elements.eventType.addEventListener('change', () => {
                    this.elements.eventAssistPlayerGroup.style.display = (this.elements.eventType.value === 'goal') ? 'block' : 'none';
                });
                this.elements.addEventBtn.addEventListener('click', () => this.addEventToMatchModal());
                this.elements.matchModalSaveBtn.addEventListener('click', () => this.saveMatchResultFromModal());

                // Team Modal event listeners
                this.elements.teamModalSaveBtn.addEventListener('click', () => this.saveTeamFromModal());

                // Player Modal event listeners
                this.elements.playerModalAddEditBtn.addEventListener('click', () => this.addEditPlayerFromModal());

                // Import file input
                this.elements.importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            app.data.importState(event.target.result);
                        };
                        reader.readAsText(file);
                    }
                });

                // Manage tab buttons
                this.elements.addTeamBtn.addEventListener('click', () => this.showTeamModal());
                this.elements.drawGroupsBtn.addEventListener('click', () => this.drawGroups());
                this.elements.generateFixturesBtn.addEventListener('click', () => this.generateFixtures());
                this.elements.resetTournamentBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to reset this tournament? All data for this tournament will be lost.')) {
                        app.data.resetTournament(app.data.currentTournamentId);
                    }
                });
                this.elements.saveTournamentSettingsBtn.addEventListener('click', () => this.saveTournamentSettings());

                // Fixtures tab filter
                this.elements.fixtureTeamFilter.addEventListener('change', () => this.renderFixtures());

                // Player stats filter
                this.elements.playerStatsTeamFilter.addEventListener('change', () => this.renderPlayerStats());

                // Export standings CSV
                this.elements.exportStandingsCsvBtn.addEventListener('click', () => app.logic.exportStandingsAsCsv(app.data.currentTournamentId));
            },

            showModal(modalId) {
                document.getElementById(modalId).classList.add('active');
            },

            hideModal(modalId) {
                document.getElementById(modalId).classList.remove('active');
            },

            showHomeView() {
                document.querySelectorAll('#main-content .tab-content').forEach(view => view.classList.remove('active'));
                this.elements.homeView.classList.add('active');
                app.data.currentTournamentId = null;
                document.querySelectorAll('.sidebar-item').forEach(item => item.classList.remove('active'));
                document.querySelector('[data-view="home"]').classList.add('active');
            },

            showCreateTournamentModal(mode = 'league') {
                document.querySelectorAll('#main-content .tab-content').forEach(view => view.classList.remove('active'));
                this.elements.createTournamentView.classList.add('active');
                this.elements.newTournamentMode.value = mode;
                app.data.currentTournamentId = null;
                document.querySelectorAll('.sidebar-item').forEach(item => item.classList.remove('active'));
                document.querySelector('[data-view="create-tournament"]').classList.add('active');
            },

            showTournamentView(tournamentId = app.data.currentTournamentId) {
                if (!tournamentId) {
                    this.showHomeView();
                    return;
                }
                app.data.currentTournamentId = tournamentId;
                document.querySelectorAll('#main-content .tab-content').forEach(view => view.classList.remove('active'));
                this.elements.tournamentView.classList.add('active');

                // Update sidebar active state
                document.querySelectorAll('.sidebar-item').forEach(item => item.classList.remove('active'));
                document.querySelector(`.sidebar-item[data-tournament-id="${tournamentId}"]`).classList.add('active');

                // Activate the last active tab or default to overview
                document.querySelectorAll('#tournament-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('#tournament-view .tab-content').forEach(content => content.classList.remove('active'));

                const activeTabButton = document.querySelector(`#tournament-tabs .tab-button[data-tab="${this.currentActiveTab}"]`);
                if (activeTabButton) {
                    activeTabButton.classList.add('active');
                    document.getElementById(`${this.currentActiveTab}-tab`).classList.add('active');
                } else {
                    this.currentActiveTab = 'overview';
                    document.querySelector('#tournament-tabs .tab-button[data-tab="overview"]').classList.add('active');
                    document.getElementById('overview-tab').classList.add('active');
                }

                this.renderCurrentTournamentView();
            },

            renderSidebar() {
                const tournamentList = this.elements.tournamentList;
                tournamentList.innerHTML = '';

                const modes = {
                    'league': 'League',
                    'champions': 'Champions League',
                    'worldcup': 'World Cup'
                };

                app.data.state.tournaments.forEach(tournament => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.classList.add('sidebar-item');
                    a.dataset.tournamentId = tournament.id;
                    a.textContent = `${tournament.name} (${modes[tournament.mode]})`;
                    if (app.data.currentTournamentId === tournament.id) {
                        a.classList.add('active');
                    }
                    li.appendChild(a);
                    tournamentList.appendChild(li);
                });
            },

            renderCurrentTournamentView() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) {
                    this.showHomeView();
                    return;
                }

                this.elements.currentTournamentName.textContent = tournament.name;
                this.renderTournamentActions(tournament);

                // Show/hide knockout tab based on mode
                this.elements.knockoutTab.style.display = (tournament.mode === 'champions' || tournament.mode === 'worldcup') ? 'block' : 'none';

                switch (this.currentActiveTab) {
                    case 'overview': this.renderOverview(); break;
                    case 'fixtures': this.renderFixtures(); break;
                    case 'standings': this.renderStandings(); break;
                    case 'player-stats': this.renderPlayerStats(); break;
                    case 'knockout': this.renderKnockoutBracket(); break;
                    case 'manage': this.renderManageSection(); break;
                }
            },

            renderTournamentActions(tournament) {
                const actionsDiv = this.elements.tournamentActions;
                actionsDiv.innerHTML = '';

                const teams = app.data.getTeamsInTournament(tournament.id);
                const fixtures = app.data.getFixtures(tournament.id);

                if (tournament.mode === 'league') {
                    if (teams.length >= 2 && fixtures.length === 0) {
                        const btn = document.createElement('button');
                        btn.classList.add('btn');
                        btn.textContent = 'Generate Fixtures';
                        btn.addEventListener('click', () => this.generateFixtures());
                        actionsDiv.appendChild(btn);
                    }
                } else { // Champions League & World Cup
                    if (teams.length >= tournament.config.numGroups * tournament.config.groupSize && !tournament.groups) {
                        const btn = document.createElement('button');
                        btn.classList.add('btn');
                        btn.textContent = 'Draw Groups';
                        btn.addEventListener('click', () => this.drawGroups());
                        actionsDiv.appendChild(btn);
                    } else if (tournament.groups && fixtures.length === 0) {
                        const btn = document.createElement('button');
                        btn.classList.add('btn');
                        btn.textContent = 'Generate Fixtures';
                        btn.addEventListener('click', () => this.generateFixtures());
                        actionsDiv.appendChild(btn);
                    }
                }
            },

            renderOverview() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const teams = app.data.getTeamsInTournament(tournament.id);
                const fixtures = app.data.getFixtures(tournament.id);
                const playedFixtures = fixtures.filter(f => f.status === 'played');

                this.elements.overviewMode.textContent = tournament.mode.replace(/\b\w/g, char => char.toUpperCase());
                this.elements.overviewNumTeams.textContent = teams.length;
                this.elements.overviewMatchesPlayed.textContent = playedFixtures.length;
                this.elements.overviewTotalMatches.textContent = fixtures.length;
                this.elements.overviewStatus.textContent = fixtures.length === 0 ? 'Setup Required' :
                                                            (playedFixtures.length === fixtures.length ? 'Completed' : 'In Progress');

                // Render next 5 scheduled fixtures
                const nextFixtures = fixtures
                    .filter(f => f.status === 'scheduled')
                    .sort((a, b) => new Date(a.date) - new Date(b.date))
                    .slice(0, 5);

                this.elements.overviewNextFixtures.innerHTML = '';
                if (nextFixtures.length === 0) {
                    this.elements.overviewNextFixtures.innerHTML = '<p class="text-center">No upcoming fixtures.</p>';
                } else {
                    nextFixtures.forEach(fixture => {
                        this.elements.overviewNextFixtures.appendChild(this.createFixtureItem(fixture));
                    });
                }
            },

            renderFixtures() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const fixtures = app.data.getFixtures(tournament.id);
                const teams = app.data.getTeamsInTournament(tournament.id);

                // Populate team filter
                this.elements.fixtureTeamFilter.innerHTML = '<option value="">All Teams</option>';
                teams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team.id;
                    option.textContent = team.name;
                    this.elements.fixtureTeamFilter.appendChild(option);
                });
                this.elements.fixtureTeamFilter.value = this.elements.fixtureTeamFilter.value || ''; // Keep selected value

                const filterTeamId = this.elements.fixtureTeamFilter.value;
                const filteredFixtures = filterTeamId
                    ? fixtures.filter(f => f.homeTeamId === filterTeamId || f.awayTeamId === filterTeamId)
                    : fixtures;

                // Sort fixtures by date
                filteredFixtures.sort((a, b) => new Date(a.date) - new Date(b.date));

                this.elements.fixturesList.innerHTML = '';
                if (filteredFixtures.length === 0) {
                    this.elements.fixturesList.innerHTML = '<p class="text-center">No fixtures generated yet.</p>';
                    this.elements.simulateAllFixturesBtn.disabled = true;
                } else {
                    filteredFixtures.forEach(fixture => {
                        this.elements.fixturesList.appendChild(this.createFixtureItem(fixture));
                    });
                    this.elements.simulateAllFixturesBtn.disabled = filteredFixtures.filter(f => f.status === 'scheduled').length === 0;
                }

                this.elements.simulateAllFixturesBtn.onclick = () => {
                    if (confirm('Are you sure you want to simulate all remaining fixtures? This cannot be undone.')) {
                        app.logic.simulateAllRemainingFixtures(tournament.id);
                        this.renderCurrentTournamentView();
                    }
                };
            },

            createFixtureItem(fixture) {
                const homeTeam = app.data.getTeam(fixture.homeTeamId);
                const awayTeam = app.data.getTeam(fixture.awayTeamId);
                const item = document.createElement('div');
                item.classList.add('fixture-item', fixture.status);
                item.dataset.fixtureId = fixture.id;
                item.addEventListener('click', () => this.showMatchModal(fixture.id));

                const scoreDisplay = fixture.status === 'played'
                    ? `${fixture.score.home} - ${fixture.score.away}`
                    : 'vs';

                const dateOptions = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                const dateTime = fixture.date ? new Date(fixture.date).toLocaleString([], dateOptions) : 'TBD';

                item.innerHTML = `
                    <div class="match-info">
                        <span class="team-name">${homeTeam ? homeTeam.name : 'TBD'}</span>
                        <span class="score">${scoreDisplay}</span>
                        <span class="team-name away">${awayTeam ? awayTeam.name : 'TBD'}</span>
                    </div>
                    <span class="date-time">${dateTime}</span>
                    <span class="status-badge ${fixture.status}">${fixture.status}</span>
                `;
                return item;
            },

            renderStandings() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                this.elements.standingsContainer.innerHTML = '';

                if (tournament.mode === 'league') {
                    const standings = app.logic.calculateStandings(tournament.id);
                    this.elements.standingsContainer.appendChild(this.createStandingsTable(standings, tournament.config.relegationSpots));
                } else { // Champions League & World Cup
                    if (!tournament.groups) {
                        this.elements.standingsContainer.innerHTML = '<p class="text-center">Groups not drawn yet. Go to "Manage" to draw groups.</p>';
                        return;
                    }
                    for (const groupId in tournament.groups) {
                        const groupStandings = app.logic.calculateStandings(tournament.id, groupId);
                        const groupCard = document.createElement('div');
                        groupCard.classList.add('group-card');
                        groupCard.innerHTML = `<h3>Group ${groupId}</h3>`;
                        groupCard.appendChild(this.createStandingsTable(groupStandings, 2)); // Top 2 advance
                        this.elements.standingsContainer.appendChild(groupCard);
                    }
                }
            },

            createStandingsTable(standings, advanceRelegateCount = 0) {
                const table = document.createElement('table');
                table.classList.add('data-table');
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Pos</th>
                            <th>Team</th>
                            <th class="sortable" data-sort="P">P</th>
                            <th class="sortable" data-sort="W">W</th>
                            <th class="sortable" data-sort="D">D</th>
                            <th class="sortable" data-sort="L">L</th>
                            <th class="sortable" data-sort="GF">GF</th>
                            <th class="sortable" data-sort="GA">GA</th>
                            <th class="sortable" data-sort="GD">GD</th>
                            <th class="sortable" data-sort="Pts">Pts</th>
                            <th class="sortable" data-sort="FairPlay">FP</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;
                const tbody = table.querySelector('tbody');

                standings.forEach((teamStats, index) => {
                    const team = app.data.getTeam(teamStats.teamId);
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td class="team-name"><span class="team-logo-placeholder"></span>${team ? team.name : 'Unknown'}</td>
                        <td>${teamStats.P}</td>
                        <td>${teamStats.W}</td>
                        <td>${teamStats.D}</td>
                        <td>${teamStats.L}</td>
                        <td>${teamStats.GF}</td>
                        <td>${teamStats.GA}</td>
                        <td>${teamStats.GD}</td>
                        <td>${teamStats.Pts}</td>
                        <td>${teamStats.FairPlay}</td>
                    `;
                    if (advanceRelegateCount > 0) {
                        if (index < advanceRelegateCount) {
                            row.style.backgroundColor = 'rgba(76, 175, 80, 0.1)'; // Green for advancing
                        } else if (index >= standings.length - advanceRelegateCount && standings.length > advanceRelegateCount) {
                            row.style.backgroundColor = 'rgba(244, 67, 54, 0.1)'; // Red for relegating
                        }
                    }
                });

                // Add sorting functionality
                table.querySelectorAll('.sortable').forEach(th => {
                    th.addEventListener('click', () => {
                        const sortKey = th.dataset.sort;
                        const currentSortOrder = th.classList.contains('asc') ? 'asc' : (th.classList.contains('desc') ? 'desc' : '');
                        let newSortOrder = 'asc';
                        if (currentSortOrder === 'asc') newSortOrder = 'desc';
                        else if (currentSortOrder === 'desc') newSortOrder = ''; // Reset sort

                        // Clear previous sort classes
                        table.querySelectorAll('.sortable').forEach(s => s.classList.remove('asc', 'desc'));

                        let sortedStandings = [...standings];
                        if (newSortOrder) {
                            sortedStandings.sort((a, b) => {
                                let valA = a[sortKey];
                                let valB = b[sortKey];

                                // Handle FairPlay (lower is better)
                                if (sortKey === 'FairPlay') {
                                    return newSortOrder === 'asc' ? valA - valB : valB - valA;
                                }

                                // Default numeric sort (higher is better)
                                return newSortOrder === 'asc' ? valB - valA : valA - valB;
                            });
                            th.classList.add(newSortOrder);
                        } else {
                            // If reset, re-calculate to get default order
                            sortedStandings = app.logic.calculateStandings(app.data.currentTournamentId, standings[0]?.groupId);
                        }
                        tbody.innerHTML = ''; // Clear existing rows
                        sortedStandings.forEach((teamStats, index) => {
                            const team = app.data.getTeam(teamStats.teamId);
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${index + 1}</td>
                                <td class="team-name"><span class="team-logo-placeholder"></span>${team ? team.name : 'Unknown'}</td>
                                <td>${teamStats.P}</td>
                                <td>${teamStats.W}</td>
                                <td>${teamStats.D}</td>
                                <td>${teamStats.L}</td>
                                <td>${teamStats.GF}</td>
                                <td>${teamStats.GA}</td>
                                <td>${teamStats.GD}</td>
                                <td>${teamStats.Pts}</td>
                                <td>${teamStats.FairPlay}</td>
                            `;
                            if (advanceRelegateCount > 0) {
                                if (index < advanceRelegateCount) {
                                    row.style.backgroundColor = 'rgba(76, 175, 80, 0.1)'; // Green for advancing
                                } else if (index >= standings.length - advanceRelegateCount && standings.length > advanceRelegateCount) {
                                    row.style.backgroundColor = 'rgba(244, 67, 54, 0.1)'; // Red for relegating
                                }
                            }
                        });
                    });
                });

                return table;
            },

            renderPlayerStats() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const allPlayers = app.logic.getAllPlayersWithStats(tournament.id);
                const teamsInTournament = app.data.getTeamsInTournament(tournament.id);

                // Populate team filter
                this.elements.playerStatsTeamFilter.innerHTML = '<option value="">All Teams</option>';
                teamsInTournament.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team.id;
                    option.textContent = team.name;
                    this.elements.playerStatsTeamFilter.appendChild(option);
                });
                this.elements.playerStatsTeamFilter.value = this.elements.playerStatsTeamFilter.value || '';

                const filterTeamId = this.elements.playerStatsTeamFilter.value;
                const filteredPlayers = filterTeamId
                    ? allPlayers.filter(p => p.teamId === filterTeamId)
                    : allPlayers;

                const renderLeaderboard = (tableBody, data, statKey, sortOrder = 'desc') => {
                    tableBody.innerHTML = '';
                    data.sort((a, b) => sortOrder === 'desc' ? b.stats[statKey] - a.stats[statKey] : a.stats[statKey] - b.stats[statKey]);
                    data.slice(0, 10).forEach((player, index) => { // Top 10
                        if (player.stats[statKey] > 0) {
                            const team = app.data.getTeam(player.teamId);
                            const row = tableBody.insertRow();
                            row.innerHTML = `
                                <td>${index + 1}</td>
                                <td>${player.name}</td>
                                <td>${team ? team.name : 'Unknown'}</td>
                                <td class="text-right">${player.stats[statKey]}</td>
                            `;
                        }
                    });
                };

                renderLeaderboard(this.elements.topScorersTable, filteredPlayers, 'goals');
                renderLeaderboard(this.elements.topAssistsTable, filteredPlayers, 'assists');
                renderLeaderboard(this.elements.topYellowCardsTable, filteredPlayers, 'yellowCards');
                renderLeaderboard(this.elements.topRedCardsTable, filteredPlayers, 'redCards');
            },

            renderKnockoutBracket() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const knockoutData = app.data.getKnockout(tournament.id);
                this.elements.knockoutBracketContainer.innerHTML = '';

                if (!knockoutData || knockoutData.rounds.length === 0) {
                    this.elements.knockoutBracketContainer.innerHTML = '<p class="text-center">Knockout stage not generated yet. Ensure group stage is complete and go to "Manage" to generate.</p>';
                    return;
                }

                const bracketWrapper = document.createElement('div');
                bracketWrapper.classList.add('knockout-rounds-wrapper');
                if (tournament.mode === 'worldcup') {
                    this.elements.knockoutBracketContainer.classList.add('worldcup-bracket');
                } else {
                    this.elements.knockoutBracketContainer.classList.remove('worldcup-bracket');
                }

                knockoutData.rounds.forEach((round, roundIndex) => {
                    const roundDiv = document.createElement('div');
                    roundDiv.classList.add('knockout-round');
                    roundDiv.innerHTML = `<h3 class="knockout-round-title">${round.name}</h3>`;
                    const matchesDiv = document.createElement('div');
                    matchesDiv.classList.add('knockout-matches');

                    round.matches.forEach((matchId, matchIndex) => {
                        const fixture = app.data.getFixture(tournament.id, matchId);
                        if (!fixture) return;

                        const homeTeam = app.data.getTeam(fixture.homeTeamId);
                        const awayTeam = app.data.getTeam(fixture.awayTeamId);

                        const matchContainer = document.createElement('div');
                        matchContainer.classList.add('knockout-match-container');

                        const matchElement = document.createElement('div');
                        matchElement.classList.add('knockout-match');
                        matchElement.dataset.fixtureId = fixture.id;
                        matchElement.addEventListener('click', () => this.showMatchModal(fixture.id));

                        let homeScore = fixture.score?.home || 0;
                        let awayScore = fixture.score?.away || 0;
                        let aggregateScoreHtml = '';
                        let winnerClass = '';

                        if (tournament.mode === 'champions' && fixture.leg) {
                            const aggregate = app.logic.getAggregateScore(tournament.id, fixture.homeTeamId, fixture.awayTeamId, fixture.roundId);
                            if (aggregate) {
                                aggregateScoreHtml = `<div class="aggregate-score">Agg: ${aggregate.home} - ${aggregate.away}</div>`;
                                if (fixture.status === 'played' && aggregate.winnerId) {
                                    if (aggregate.winnerId === fixture.homeTeamId) matchElement.classList.add('winner');
                                }
                            }
                        } else if (tournament.mode === 'worldcup' && fixture.status === 'played' && fixture.winnerId) {
                            if (fixture.winnerId === fixture.homeTeamId) matchElement.classList.add('winner');
                        }

                        matchElement.innerHTML = `
                            <div class="team-line">
                                <span class="team-name">${homeTeam ? homeTeam.name : 'TBD'}</span>
                                <span class="score">${fixture.status === 'played' ? homeScore : ''}</span>
                            </div>
                            <div class="team-line">
                                <span class="team-name">${awayTeam ? awayTeam.name : 'TBD'}</span>
                                <span class="score">${fixture.status === 'played' ? awayScore : ''}</span>
                            </div>
                            ${aggregateScoreHtml}
                        `;
                        matchContainer.appendChild(matchElement);

                        // Add bracket lines and arrows for Champions League
                        if (tournament.mode === 'champions') {
                            if (roundIndex < knockoutData.rounds.length - 1) { // Not the final round
                                const arrow = document.createElement('div');
                                arrow.classList.add('bracket-arrow');
                                matchContainer.appendChild(arrow);
                            }
                        }
                        matchesDiv.appendChild(matchContainer);
                    });
                    roundDiv.appendChild(matchesDiv);
                    bracketWrapper.appendChild(roundDiv);
                });
                this.elements.knockoutBracketContainer.appendChild(bracketWrapper);

                // World Cup specific bracket rendering (more complex lines)
                if (tournament.mode === 'worldcup') {
                    this.renderWorldCupBracketLines(bracketWrapper, knockoutData);
                }
            },

            renderWorldCupBracketLines(bracketWrapper, knockoutData) {
                const rounds = bracketWrapper.querySelectorAll('.knockout-round');
                rounds.forEach((roundDiv, roundIndex) => {
                    const matches = roundDiv.querySelectorAll('.knockout-match-container');
                    matches.forEach((matchContainer, matchIndex) => {
                        // Horizontal line to the match
                        const connector = document.createElement('div');
                        connector.classList.add('bracket-connector');
                        matchContainer.appendChild(connector);

                        if (roundIndex < rounds.length - 1) { // Not the final round
                            matchContainer.classList.add('has-next-match');

                            // Vertical line connecting two matches
                            if (matchIndex % 2 === 0 && matches[matchIndex + 1]) {
                                const verticalConnector = document.createElement('div');
                                verticalConnector.classList.add('bracket-connector-vertical');
                                matchContainer.appendChild(verticalConnector);
                            }

                            // Horizontal line to the next round
                            const horizontalNextConnector = document.createElement('div');
                            horizontalNextConnector.classList.add('bracket-connector-horizontal-next');
                            matchContainer.appendChild(horizontalNextConnector);

                            // Arrow for advancing team
                            const arrow = document.createElement('div');
                            arrow.classList.add('bracket-arrow');
                            matchContainer.appendChild(arrow);
                        }
                    });
                });
            },

            renderManageSection() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                this.renderTournamentSettingsForm(tournament);
                this.renderManageTeamsTable(tournament);

                // Show/hide generate/draw buttons
                const teams = app.data.getTeamsInTournament(tournament.id);
                const fixtures = app.data.getFixtures(tournament.id);

                if (tournament.mode === 'league') {
                    this.elements.drawGroupsBtn.style.display = 'none';
                    this.elements.generateFixturesBtn.style.display = (teams.length >= 2 && fixtures.length === 0) ? 'inline-block' : 'none';
                } else { // Champions League & World Cup
                    this.elements.drawGroupsBtn.style.display = (teams.length >= tournament.config.numGroups * tournament.config.groupSize && !tournament.groups) ? 'inline-block' : 'none';
                    this.elements.generateFixturesBtn.style.display = (tournament.groups && fixtures.length === 0) ? 'inline-block' : 'none';
                }
            },

            renderTournamentSettingsForm(tournament) {
                const form = this.elements.tournamentSettingsForm;
                form.innerHTML = '';

                const createInput = (id, label, type, value, min = null, max = null, step = null) => {
                    const div = document.createElement('div');
                    div.classList.add('form-group');
                    div.innerHTML = `<label for="${id}">${label}:</label>`;
                    const input = document.createElement('input');
                    input.type = type;
                    input.id = id;
                    input.value = value;
                    if (min !== null) input.min = min;
                    if (max !== null) input.max = max;
                    if (step !== null) input.step = step;
                    div.appendChild(input);
                    return div;
                };

                const createSelect = (id, label, options, selectedValue) => {
                    const div = document.createElement('div');
                    div.classList.add('form-group');
                    div.innerHTML = `<label for="${id}">${label}:</label>`;
                    const select = document.createElement('select');
                    select.id = id;
                    options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        if (opt.value === selectedValue) option.selected = true;
                        select.appendChild(option);
                    });
                    div.appendChild(select);
                    return div;
                };

                const createCheckbox = (id, label, checked) => {
                    const div = document.createElement('div');
                    div.classList.add('form-group');
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = id;
                    input.checked = checked;
                    const labelElem = document.createElement('label');
                    labelElem.htmlFor = id;
                    labelElem.textContent = label;
                    div.appendChild(input);
                    div.appendChild(labelElem);
                    return div;
                };

                form.appendChild(createInput('tournament-name-setting', 'Tournament Name', 'text', tournament.name));

                if (tournament.mode === 'league') {
                    form.appendChild(createSelect('league-round-robin-type', 'Round-Robin Type', [
                        { value: 'single', text: 'Single Round-Robin' },
                        { value: 'double', text: 'Double Round-Robin' }
                    ], tournament.config.roundRobinType));
                    form.appendChild(createInput('league-points-win', 'Points for Win', 'number', tournament.config.pointsWin, 0));
                    form.appendChild(createInput('league-points-draw', 'Points for Draw', 'number', tournament.config.pointsDraw, 0));
                    form.appendChild(createInput('league-points-loss', 'Points for Loss', 'number', tournament.config.pointsLoss, 0));
                    form.appendChild(createInput('league-relegation-spots', 'Relegation Spots (visual)', 'number', tournament.config.relegationSpots, 0));

                    const tieBreakerOrderDiv = document.createElement('div');
                    tieBreakerOrderDiv.classList.add('form-group');
                    tieBreakerOrderDiv.innerHTML = `<label for="league-tie-breaker-order">Tie-breaker Order (comma-separated):</label>
                                                    <input type="text" id="league-tie-breaker-order" value="${tournament.config.tieBreakerOrder.join(', ')}">
                                                    <small>Options: points, goalDifference, goalsFor, headToHeadPoints, headToHeadGoalDifference, fairPlay, alphabetical</small>`;
                    form.appendChild(tieBreakerOrderDiv);

                } else if (tournament.mode === 'champions' || tournament.mode === 'worldcup') {
                    form.appendChild(createInput('group-size', 'Teams per Group', 'number', tournament.config.groupSize, 2, 8));
                    form.appendChild(createInput('num-groups', 'Number of Groups', 'number', tournament.config.numGroups, 2, 16));
                    form.appendChild(createSelect('group-stage-round-robin-type', 'Group Stage Round-Robin Type', [
                        { value: 'single', text: 'Single Round-Robin' },
                        { value: 'double', text: 'Double Round-Robin' }
                    ], tournament.config.groupStageRoundRobinType));

                    if (tournament.mode === 'champions') {
                        form.appendChild(createCheckbox('away-goals-rule-enabled', 'Enable Away Goals Rule (Knockout)', tournament.config.awayGoalsRuleEnabled));
                    }
                }
            },

            saveTournamentSettings() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                tournament.name = document.getElementById('tournament-name-setting').value.trim();

                if (tournament.mode === 'league') {
                    tournament.config.roundRobinType = document.getElementById('league-round-robin-type').value;
                    tournament.config.pointsWin = parseInt(document.getElementById('league-points-win').value);
                    tournament.config.pointsDraw = parseInt(document.getElementById('league-points-draw').value);
                    tournament.config.pointsLoss = parseInt(document.getElementById('league-points-loss').value);
                    tournament.config.relegationSpots = parseInt(document.getElementById('league-relegation-spots').value);
                    tournament.config.tieBreakerOrder = document.getElementById('league-tie-breaker-order').value.split(',').map(s => s.trim()).filter(Boolean);
                } else if (tournament.mode === 'champions' || tournament.mode === 'worldcup') {
                    tournament.config.groupSize = parseInt(document.getElementById('group-size').value);
                    tournament.config.numGroups = parseInt(document.getElementById('num-groups').value);
                    tournament.config.groupStageRoundRobinType = document.getElementById('group-stage-round-robin-type').value;
                    if (tournament.mode === 'champions') {
                        tournament.config.awayGoalsRuleEnabled = document.getElementById('away-goals-rule-enabled').checked;
                    }
                }

                app.data.saveState();
                this.renderSidebar(); // Update tournament name in sidebar
                this.renderCurrentTournamentView(); // Re-render current view with new settings
                alert('Tournament settings saved!');
            },

            renderManageTeamsTable(tournament) {
                const tbody = this.elements.manageTeamsTable;
                tbody.innerHTML = '';

                const teams = app.data.getTeamsInTournament(tournament.id);
                teams.forEach(team => {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${team.name}</td>
                        <td>${team.shortName || ''}</td>
                        <td>${team.country || ''}</td>
                        <td>
                            <button class="btn" style="background-color: var(--info-color); padding: 5px 10px;" onclick="app.ui.showTeamModal('${team.id}')">Edit</button>
                            <button class="btn" style="background-color: var(--success-color); padding: 5px 10px;" onclick="app.ui.showPlayerModal('${team.id}')">Players</button>
                            <button class="btn" style="background-color: var(--error-color); padding: 5px 10px;" onclick="app.ui.deleteTeam('${team.id}')">Delete</button>
                        </td>
                    `;
                });
            },

            showTeamModal(teamId = null) {
                this.elements.teamModalId.value = '';
                this.elements.teamName.value = '';
                this.elements.teamShortName.value = '';
                this.elements.teamCountry.value = '';
                this.elements.teamPrimaryColor.value = '#005792';
                this.elements.teamSecondaryColor.value = '#FFFFFF';

                if (teamId) {
                    const team = app.data.getTeam(teamId);
                    if (team) {
                        this.elements.teamModalTitle.textContent = `Edit Team: ${team.name}`;
                        this.elements.teamModalId.value = team.id;
                        this.elements.teamName.value = team.name;
                        this.elements.teamShortName.value = team.shortName || '';
                        this.elements.teamCountry.value = team.country || '';
                        this.elements.teamPrimaryColor.value = team.primaryColor || '#005792';
                        this.elements.teamSecondaryColor.value = team.secondaryColor || '#FFFFFF';
                    }
                } else {
                    this.elements.teamModalTitle.textContent = 'Add New Team';
                }
                this.showModal('team-modal');
            },

            saveTeamFromModal() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const teamId = this.elements.teamModalId.value;
                const name = this.elements.teamName.value.trim();
                const shortName = this.elements.teamShortName.value.trim().toUpperCase();
                const country = this.elements.teamCountry.value.trim();
                const primaryColor = this.elements.teamPrimaryColor.value;
                const secondaryColor = this.elements.teamSecondaryColor.value;

                if (!name) {
                    alert('Team name is required.');
                    return;
                }

                if (teamId) {
                    // Edit existing team
                    const team = app.data.getTeam(teamId);
                    if (team) {
                        team.name = name;
                        team.shortName = shortName;
                        team.country = country;
                        team.primaryColor = primaryColor;
                        team.secondaryColor = secondaryColor;
                    }
                } else {
                    // Add new team
                    const newTeam = {
                        id: app.data.generateUniqueId(),
                        name,
                        shortName,
                        country,
                        primaryColor,
                        secondaryColor,
                        stats: { P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0, FairPlay: 0 }
                    };
                    app.data.state.teams[newTeam.id] = newTeam;
                    tournament.teams.push(newTeam.id);
                }

                app.data.saveState();
                this.hideModal('team-modal');
                this.renderManageTeamsTable(tournament);
                this.renderTournamentActions(tournament); // Update generate/draw buttons
            },

            deleteTeam(teamId) {
                if (!confirm('Are you sure you want to delete this team? This will also remove all its players and affect fixtures/standings.')) {
                    return;
                }
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                // Remove team from tournament's team list
                tournament.teams = tournament.teams.filter(id => id !== teamId);

                // Remove team from global teams object
                delete app.data.state.teams[teamId];

                // Remove players associated with the team
                delete app.data.state.players[teamId];

                // Invalidate fixtures and standings (simplification: regenerate or mark as invalid)
                // For now, we'll just clear fixtures and standings to force regeneration
                delete app.data.state.fixtures[tournament.id];
                delete app.data.state.standings[tournament.id];
                delete app.data.state.knockout[tournament.id];
                delete tournament.groups; // Clear groups if any

                app.data.saveState();
                this.renderManageTeamsTable(tournament);
                this.renderTournamentActions(tournament);
                this.renderCurrentTournamentView(); // Re-render to reflect changes
            },

            showPlayerModal(teamId) {
                this.currentTeamIdForPlayers = teamId;
                const team = app.data.getTeam(teamId);
                if (!team) return;

                this.elements.playerModalTeamName.textContent = team.name;
                this.elements.playerModalTeamId.value = teamId;
                this.elements.editPlayerId.value = '';
                this.elements.playerName.value = '';
                this.elements.playerNumber.value = '';
                this.elements.playerPosition.value = '';
                this.elements.playerModalAddEditBtn.textContent = 'Add Player';

                this.renderPlayersInModal(teamId);
                this.showModal('player-modal');
            },

            renderPlayersInModal(teamId) {
                const tbody = this.elements.managePlayersTable;
                tbody.innerHTML = '';

                const players = app.data.getPlayersInTeam(teamId);
                players.forEach(player => {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${player.number || ''}</td>
                        <td>${player.name}</td>
                        <td>${player.position || ''}</td>
                        <td>
                            <button class="btn" style="background-color: var(--info-color); padding: 5px 10px;" onclick="app.ui.editPlayer('${teamId}', '${player.id}')">Edit</button>
                            <button class="btn" style="background-color: var(--error-color); padding: 5px 10px;" onclick="app.ui.deletePlayer('${teamId}', '${player.id}')">Delete</button>
                        </td>
                    `;
                });
            },

            addEditPlayerFromModal() {
                const teamId = this.elements.playerModalTeamId.value;
                const playerId = this.elements.editPlayerId.value;
                const name = this.elements.playerName.value.trim();
                const number = parseInt(this.elements.playerNumber.value);
                const position = this.elements.playerPosition.value.trim();

                if (!name) {
                    alert('Player name is required.');
                    return;
                }

                if (!app.data.state.players[teamId]) {
                    app.data.state.players[teamId] = [];
                }

                if (playerId) {
                    // Edit existing player
                    const player = app.data.getPlayersInTeam(teamId).find(p => p.id === playerId);
                    if (player) {
                        player.name = name;
                        player.number = number;
                        player.position = position;
                    }
                } else {
                    // Add new player
                    const newPlayer = {
                        id: app.data.generateUniqueId(),
                        name,
                        number: isNaN(number) ? null : number,
                        position,
                        stats: { goals: 0, assists: 0, yellowCards: 0, redCards: 0, minutes: 0 }
                    };
                    app.data.state.players[teamId].push(newPlayer);
                }

                app.data.saveState();
                this.renderPlayersInModal(teamId);
                // Clear form for next entry
                this.elements.editPlayerId.value = '';
                this.elements.playerName.value = '';
                this.elements.playerNumber.value = '';
                this.elements.playerPosition.value = '';
                this.elements.playerModalAddEditBtn.textContent = 'Add Player';
            },

            editPlayer(teamId, playerId) {
                const player = app.data.getPlayer(teamId, playerId);
                if (player) {
                    this.elements.editPlayerId.value = player.id;
                    this.elements.playerName.value = player.name;
                    this.elements.playerNumber.value = player.number || '';
                    this.elements.playerPosition.value = player.position || '';
                    this.elements.playerModalAddEditBtn.textContent = 'Update Player';
                }
            },

            deletePlayer(teamId, playerId) {
                if (!confirm('Are you sure you want to delete this player?')) {
                    return;
                }
                if (app.data.state.players[teamId]) {
                    app.data.state.players[teamId] = app.data.state.players[teamId].filter(p => p.id !== playerId);
                    app.data.saveState();
                    this.renderPlayersInModal(teamId);
                }
            },

            drawGroups() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const teams = app.data.getTeamsInTournament(tournament.id);
                if (teams.length < tournament.config.numGroups * tournament.config.groupSize) {
                    alert(`Not enough teams to fill all groups. Need ${tournament.config.numGroups * tournament.config.groupSize} teams.`);
                    return;
                }

                if (confirm('Are you sure you want to draw new groups? This will clear existing groups and fixtures.')) {
                    app.logic.drawGroups(tournament.id);
                    this.renderCurrentTournamentView();
                    alert('Groups drawn successfully!');
                }
            },

            generateFixtures() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                if (!tournament) return;

                const teams = app.data.getTeamsInTournament(tournament.id);
                if (teams.length < 2) {
                    alert('Need at least 2 teams to generate fixtures.');
                    return;
                }

                if (tournament.mode !== 'league' && !tournament.groups) {
                    alert('Please draw groups first for Champions League/World Cup.');
                    return;
                }

                if (confirm('Are you sure you want to generate new fixtures? This will clear any existing fixtures and results.')) {
                    app.logic.generateFixtures(tournament.id);
                    this.renderCurrentTournamentView();
                    alert('Fixtures generated successfully!');
                }
            },

            showMatchModal(fixtureId) {
                this.currentMatchFixtureId = fixtureId;
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                const fixture = app.data.getFixture(tournament.id, fixtureId);
                if (!fixture) return;

                const homeTeam = app.data.getTeam(fixture.homeTeamId);
                const awayTeam = app.data.getTeam(fixture.awayTeamId);

                this.elements.matchModalTitle.textContent = `${homeTeam.name} vs ${awayTeam.name}`;
                this.elements.matchModalDate.textContent = fixture.date ? new Date(fixture.date).toLocaleString() : 'Date TBD';
                this.elements.matchModalHomeTeam.textContent = homeTeam.name;
                this.elements.matchModalAwayTeam.textContent = awayTeam.name;
                this.elements.matchModalHomeScore.value = fixture.score?.home || 0;
                this.elements.matchModalAwayScore.value = fixture.score?.away || 0;

                // Reset ET/Penalties sections
                this.elements.matchModalExtraTimeSection.style.display = 'none';
                this.elements.matchModalPenaltiesSection.style.display = 'none';
                this.elements.matchModalHomeScoreET.value = 0;
                this.elements.matchModalAwayScoreET.value = 0;
                this.elements.matchModalHomeScorePen.value = 0;
                this.elements.matchModalAwayScorePen.value = 0;

                // Show ET/Penalties buttons for knockout matches
                const isKnockout = fixture.stage === 'knockout';
                this.elements.matchModalExtraTimeBtn.style.display = isKnockout ? 'inline-block' : 'none';
                this.elements.matchModalPenaltiesBtn.style.display = 'none'; // Only show after ET

                if (fixture.extraTime) {
                    this.toggleExtraTimeInput(true);
                    this.elements.matchModalHomeScoreET.value = fixture.extraTime.home || 0;
                    this.elements.matchModalAwayScoreET.value = fixture.extraTime.away || 0;
                    if (fixture.penalties) {
                        this.togglePenaltiesInput(true);
                        this.elements.matchModalHomeScorePen.value = fixture.penalties.home || 0;
                        this.elements.matchModalAwayScorePen.value = fixture.penalties.away || 0;
                    } else {
                        this.elements.matchModalPenaltiesBtn.style.display = 'inline-block';
                    }
                }

                // Populate event player selects
                this.populatePlayerSelect(fixture.homeTeamId, this.elements.eventPlayer, fixture.awayTeamId);
                this.populatePlayerSelect(fixture.homeTeamId, this.elements.eventAssistPlayer, fixture.awayTeamId, true); // For assists, include both teams
                this.populateEventTeamSelect(fixture.homeTeamId, fixture.awayTeamId);
                this.elements.eventAssistPlayerGroup.style.display = (this.elements.eventType.value === 'goal') ? 'block' : 'none';

                this.renderMatchEvents(fixture.events || []);
                this.showModal('match-modal');
            },

            populateEventTeamSelect(homeTeamId, awayTeamId) {
                this.elements.eventPlayerTeam.innerHTML = '';
                const homeTeam = app.data.getTeam(homeTeamId);
                const awayTeam = app.data.getTeam(awayTeamId);

                const homeOption = document.createElement('option');
                homeOption.value = homeTeamId;
                homeOption.textContent = homeTeam.name;
                this.elements.eventPlayerTeam.appendChild(homeOption);

                const awayOption = document.createElement('option');
                awayOption.value = awayTeamId;
                awayOption.textContent = awayTeam.name;
                this.elements.eventPlayerTeam.appendChild(awayOption);
            },

            populatePlayerSelect(selectedTeamId, selectElement, otherTeamId = null, includeBothTeams = false) {
                selectElement.innerHTML = '';
                if (selectElement.id === 'event-assist-player') {
                    const noneOption = document.createElement('option');
                    noneOption.value = '';
                    noneOption.textContent = 'None';
                    selectElement.appendChild(noneOption);
                }

                const addPlayers = (teamId) => {
                    const team = app.data.getTeam(teamId);
                    if (team) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = team.name;
                        const players = app.data.getPlayersInTeam(teamId);
                        players.forEach(player => {
                            const option = document.createElement('option');
                            option.value = player.id;
                            option.textContent = `${player.name} (#${player.number || 'N/A'})`;
                            optgroup.appendChild(option);
                        });
                        selectElement.appendChild(optgroup);
                    }
                };

                addPlayers(selectedTeamId);
                if (includeBothTeams && otherTeamId && otherTeamId !== selectedTeamId) {
                    addPlayers(otherTeamId);
                }
            },

            renderMatchEvents(events) {
                this.elements.matchModalEventsList.innerHTML = '';
                events.sort((a, b) => a.minute - b.minute);
                events.forEach((event, index) => {
                    const player = app.data.getPlayer(event.teamId, event.playerId);
                    const team = app.data.getTeam(event.teamId);
                    let eventText = `${event.minute}' - ${player ? player.name : 'Unknown Player'} (${team ? team.shortName : 'UNK'})`;
                    let eventClass = '';

                    switch (event.type) {
                        case 'goal':
                            eventClass = 'event-type-goal';
                            const assistPlayer = event.assistId ? app.data.getPlayer(event.teamId, event.assistId) : null;
                            eventText += ` scored! ${assistPlayer ? `(Assist: ${assistPlayer.name})` : ''}`;
                            break;
                        case 'assist':
                            eventClass = 'event-type-assist';
                            eventText += ` assist`;
                            break;
                        case 'yellow':
                            eventClass = 'event-type-yellow';
                            eventText += ` yellow card`;
                            break;
                        case 'red':
                            eventClass = 'event-type-red';
                            eventText += ` red card`;
                            break;
                    }

                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="event-details ${eventClass}">${eventText}</span>
                        <div class="event-actions">
                            <button onclick="app.ui.removeEventFromMatchModal('${event.id}')">Remove</button>
                        </div>
                    `;
                    li.dataset.eventId = event.id;
                    this.elements.matchModalEventsList.appendChild(li);
                });
            },

            addEventToMatchModal() {
                const fixture = app.data.getFixture(app.data.currentTournamentId, this.currentMatchFixtureId);
                if (!fixture) return;

                const eventType = this.elements.eventType.value;
                const eventMinute = parseInt(this.elements.eventMinute.value);
                const eventPlayerId = this.elements.eventPlayer.value;
                const eventPlayerTeamId = this.elements.eventPlayerTeam.value;
                const eventAssistPlayerId = this.elements.eventAssistPlayer.value;

                if (!eventPlayerId) {
                    alert('Please select a player for the event.');
                    return;
                }
                if (isNaN(eventMinute) || eventMinute < 1) {
                    alert('Please enter a valid minute for the event.');
                    return;
                }

                const newEvent = {
                    id: app.data.generateUniqueId(),
                    minute: eventMinute,
                    type: eventType,
                    playerId: eventPlayerId,
                    teamId: eventPlayerTeamId,
                    assistId: (eventType === 'goal' && eventAssistPlayerId) ? eventAssistPlayerId : null
                };

                if (!fixture.events) fixture.events = [];
                fixture.events.push(newEvent);
                this.renderMatchEvents(fixture.events);
            },

            removeEventFromMatchModal(eventId) {
                const fixture = app.data.getFixture(app.data.currentTournamentId, this.currentMatchFixtureId);
                if (!fixture || !fixture.events) return;

                fixture.events = fixture.events.filter(e => e.id !== eventId);
                this.renderMatchEvents(fixture.events);
            },

            simulateMatchInModal() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                const fixture = app.data.getFixture(tournament.id, this.currentMatchFixtureId);
                if (!fixture) return;

                const simulatedScore = app.logic.simulateMatch(fixture.homeTeamId, fixture.awayTeamId);
                this.elements.matchModalHomeScore.value = simulatedScore.home;
                this.elements.matchModalAwayScore.value = simulatedScore.away;

                // Clear ET/Penalties if they were previously added
                this.toggleExtraTimeInput(false);
                this.togglePenaltiesInput(false);

                // If knockout and score is tied, suggest ET
                if (fixture.stage === 'knockout' && simulatedScore.home === simulatedScore.away) {
                    this.elements.matchModalExtraTimeBtn.style.display = 'inline-block';
                } else {
                    this.elements.matchModalExtraTimeBtn.style.display = 'none';
                }
            },

            toggleExtraTimeInput(show) {
                this.elements.matchModalExtraTimeSection.style.display = show ? 'block' : 'none';
                this.elements.matchModalExtraTimeBtn.style.display = show ? 'none' : 'inline-block';
                if (!show) {
                    this.elements.matchModalHomeScoreET.value = 0;
                    this.elements.matchModalAwayScoreET.value = 0;
                    this.togglePenaltiesInput(false); // Hide penalties if ET is hidden
                } else {
                    // If ET is shown, and scores are still tied, show penalties button
                    const homeScore = parseInt(this.elements.matchModalHomeScore.value);
                    const awayScore = parseInt(this.elements.matchModalAwayScore.value);
                    if (homeScore === awayScore) {
                        this.elements.matchModalPenaltiesBtn.style.display = 'inline-block';
                    }
                }
            },

            togglePenaltiesInput(show) {
                this.elements.matchModalPenaltiesSection.style.display = show ? 'block' : 'none';
                this.elements.matchModalPenaltiesBtn.style.display = show ? 'none' : 'inline-block';
                if (!show) {
                    this.elements.matchModalHomeScorePen.value = 0;
                    this.elements.matchModalAwayScorePen.value = 0;
                }
            },

            saveMatchResultFromModal() {
                const tournament = app.data.getTournament(app.data.currentTournamentId);
                const fixture = app.data.getFixture(tournament.id, this.currentMatchFixtureId);
                if (!fixture) return;

                const homeScore = parseInt(this.elements.matchModalHomeScore.value);
                const awayScore = parseInt(this.elements.matchModalAwayScore.value);

                if (isNaN(homeScore) || isNaN(awayScore) || homeScore < 0 || awayScore < 0) {
                    alert('Please enter valid scores.');
                    return;
                }

                const result = {
                    home: homeScore,
                    away: awayScore
                };

                let extraTimeResult = null;
                if (this.elements.matchModalExtraTimeSection.style.display === 'block') {
                    const homeET = parseInt(this.elements.matchModalHomeScoreET.value);
                    const awayET = parseInt(this.elements.matchModalAwayScoreET.value);
                    if (isNaN(homeET) || isNaN(awayET) || homeET < 0 || awayET < 0) {
                        alert('Please enter valid extra time scores.');
                        return;
                    }
                    extraTimeResult = { home: homeET, away: awayET };
                }

                let penaltiesResult = null;
                if (this.elements.matchModalPenaltiesSection.style.display === 'block') {
                    const homePen = parseInt(this.elements.matchModalHomeScorePen.value);
                    const awayPen = parseInt(this.elements.matchModalAwayScorePen.value);
                    if (isNaN(homePen) || isNaN(awayPen) || homePen < 0 || awayPen < 0) {
                        alert('Please enter valid penalty shootout scores.');
                        return;
                    }
                    penaltiesResult = { home: homePen, away: awayPen };
                }

                app.logic.updateMatchResult(tournament.id, fixture.id, result, fixture.events, extraTimeResult, penaltiesResult);
                this.hideModal('match-modal');
                this.renderCurrentTournamentView(); // Re-render all relevant sections
            }
        };

        // --- Tournament Logic ---
        app.logic = {
            init() {
                // Any logic initialization if needed
            },

            createTournament(name, mode) {
                const newTournament = {
                    id: app.data.generateUniqueId(),
                    name,
                    mode,
                    teams: [], // Array of team IDs
                    config: this.getDefaultTournamentConfig(mode),
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                };
                app.data.state.tournaments.push(newTournament);
                app.data.saveState();
                app.data.currentTournamentId = newTournament.id;
                return newTournament;
            },

            getDefaultTournamentConfig(mode) {
                const baseConfig = {
                    pointsWin: 3,
                    pointsDraw: 1,
                    pointsLoss: 0,
                };

                if (mode === 'league') {
                    return {
                        ...baseConfig,
                        roundRobinType: 'double', // 'single' or 'double'
                        relegationSpots: 3,
                        tieBreakerOrder: ['points', 'goalDifference', 'goalsFor', 'headToHeadPoints', 'headToHeadGoalDifference', 'fairPlay', 'alphabetical']
                    };
                } else if (mode === 'champions') {
                    return {
                        ...baseConfig,
                        groupSize: 4,
                        numGroups: 8,
                        groupStageRoundRobinType: 'double',
                        awayGoalsRuleEnabled: false,
                    };
                } else if (mode === 'worldcup') {
                    return {
                        ...baseConfig,
                        groupSize: 4,
                        numGroups: 8,
                        groupStageRoundRobinType: 'single',
                    };
                }
                return baseConfig;
            },

            // --- Fixture Generation ---
            generateFixtures(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return;

                const teams = app.data.getTeamsInTournament(tournamentId);
                if (teams.length < 2) {
                    console.error('Not enough teams to generate fixtures.');
                    return;
                }

                let generatedFixtures = [];
                if (tournament.mode === 'league') {
                    generatedFixtures = this.generateLeagueFixtures(tournament.id, teams, tournament.config.roundRobinType);
                } else { // Champions League & World Cup
                    if (!tournament.groups) {
                        console.error('Groups not drawn for group stage tournament.');
                        return;
                    }
                    generatedFixtures = this.generateGroupStageFixtures(tournament.id, tournament.groups, tournament.config.groupStageRoundRobinType);
                }

                app.data.state.fixtures[tournamentId] = generatedFixtures;
                app.data.state.standings[tournamentId] = {}; // Clear standings
                app.data.state.knockout[tournamentId] = null; // Clear knockout
                app.data.saveState();
            },

            generateLeagueFixtures(tournamentId, teams, roundRobinType = 'double') {
                const numTeams = teams.length;
                const fixtures = [];
                const teamIds = teams.map(t => t.id);

                if (numTeams % 2 !== 0) {
                    teamIds.push('BYE'); // Add a dummy team for odd number of teams
                }

                const numRounds = (numTeams % 2 === 0) ? numTeams - 1 : numTeams;
                const half = teamIds.length / 2;

                for (let round = 0; round < numRounds; round++) {
                    for (let i = 0; i < half; i++) {
                        const homeTeamId = teamIds[i];
                        const awayTeamId = teamIds[teamIds.length - 1 - i];

                        if (homeTeamId !== 'BYE' && awayTeamId !== 'BYE') {
                            // First leg
                            fixtures.push({
                                id: app.data.generateUniqueId(),
                                tournamentId,
                                date: new Date(Date.now() + (round * 7 * 24 * 60 * 60 * 1000)).toISOString(), // Weekly matches
                                homeTeamId: homeTeamId,
                                awayTeamId: awayTeamId,
                                stage: 'league',
                                leg: 1,
                                status: 'scheduled',
                                score: { home: null, away: null },
                                events: []
                            });
                        }
                    }

                    // Rotate teams (Berger table method)
                    const lastTeam = teamIds.pop();
                    teamIds.splice(1, 0, lastTeam);
                }

                if (roundRobinType === 'double') {
                    const secondLegFixtures = fixtures.map(f => ({
                        ...f,
                        id: app.data.generateUniqueId(),
                        homeTeamId: f.awayTeamId, // Swap home and away
                        awayTeamId: f.homeTeamId,
                        leg: 2,
                        date: new Date(new Date(f.date).getTime() + (numRounds * 7 * 24 * 60 * 60 * 1000)).toISOString(), // Offset dates for second leg
                    }));
                    fixtures.push(...secondLegFixtures);
                }

                return fixtures;
            },

            drawGroups(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return;

                const allTeams = app.data.getTeamsInTournament(tournamentId);
                const numGroups = tournament.config.numGroups;
                const groupSize = tournament.config.groupSize;

                if (allTeams.length < numGroups * groupSize) {
                    alert(`Not enough teams (${allTeams.length}) for ${numGroups} groups of ${groupSize} teams each. Need ${numGroups * groupSize} teams.`);
                    return;
                }

                // Shuffle teams
                const shuffledTeams = [...allTeams].sort(() => Math.random() - 0.5);

                const groups = {};
                for (let i = 0; i < numGroups; i++) {
                    const groupName = String.fromCharCode(65 + i); // A, B, C...
                    groups[groupName] = [];
                }

                let currentGroupIndex = 0;
                for (const team of shuffledTeams) {
                    const groupName = String.fromCharCode(65 + currentGroupIndex);
                    groups[groupName].push(team.id);

                    // Simple country protection: try to avoid same country in same group
                    // This is a best-effort attempt and might not always succeed if many teams from same country
                    const teamsInCurrentGroup = groups[groupName].map(id => app.data.getTeam(id));
                    const currentGroupCountries = new Set(teamsInCurrentGroup.map(t => t.country));
                    if (currentGroupCountries.has(team.country) && teamsInCurrentGroup.filter(t => t.country === team.country).length > 1) {
                        // If same country, try next group
                        groups[groupName].pop(); // Remove team
                        let nextAvailableGroup = -1;
                        for (let j = 1; j <= numGroups; j++) {
                            const nextGroupIdx = (currentGroupIndex + j) % numGroups;
                            const nextGroupName = String.fromCharCode(65 + nextGroupIdx);
                            const teamsInNextGroup = groups[nextGroupName].map(id => app.data.getTeam(id));
                            const nextGroupCountries = new Set(teamsInNextGroup.map(t => t.country));
                            if (!nextGroupCountries.has(team.country) && teamsInNextGroup.length < groupSize) {
                                nextAvailableGroup = nextGroupIdx;
                                break;
                            }
                        }
                        if (nextAvailableGroup !== -1) {
                            groups[String.fromCharCode(65 + nextAvailableGroup)].push(team.id);
                        } else {
                            // Fallback: if no other group available, put it back in original group
                            groups[groupName].push(team.id);
                            console.warn(`Could not avoid same country for ${team.name} in group ${groupName}.`);
                        }
                    }

                    if (groups[groupName].length >= groupSize) {
                        currentGroupIndex = (currentGroupIndex + 1) % numGroups;
                    }
                }

                tournament.groups = groups;
                app.data.saveState();
            },

            generateGroupStageFixtures(tournamentId, groups, roundRobinType = 'single') {
                const fixtures = [];
                let fixtureDate = new Date();

                for (const groupId in groups) {
                    const teamIds = groups[groupId];
                    const numTeams = teamIds.length;

                    if (numTeams < 2) continue;

                    // Generate round-robin for each group
                    const groupFixtures = [];
                    for (let i = 0; i < numTeams; i++) {
                        for (let j = i + 1; j < numTeams; j++) {
                            const homeTeamId = teamIds[i];
                            const awayTeamId = teamIds[j];

                            // First leg
                            groupFixtures.push({
                                id: app.data.generateUniqueId(),
                                tournamentId,
                                date: new Date(fixtureDate.getTime()).toISOString(),
                                homeTeamId: homeTeamId,
                                awayTeamId: awayTeamId,
                                stage: 'group',
                                groupId: groupId,
                                leg: 1,
                                status: 'scheduled',
                                score: { home: null, away: null },
                                events: []
                            });

                            if (roundRobinType === 'double') {
                                // Second leg
                                groupFixtures.push({
                                    id: app.data.generateUniqueId(),
                                    tournamentId,
                                    date: new Date(fixtureDate.getTime() + (7 * 24 * 60 * 60 * 1000)).toISOString(), // A week later
                                    homeTeamId: awayTeamId,
                                    awayTeamId: homeTeamId,
                                    stage: 'group',
                                    groupId: groupId,
                                    leg: 2,
                                    status: 'scheduled',
                                    score: { home: null, away: null },
                                    events: []
                                });
                            }
                        }
                    }
                    fixtures.push(...groupFixtures);
                    fixtureDate.setDate(fixtureDate.getDate() + 7); // Advance date for next group's first match
                }
                return fixtures;
            },

            generateKnockoutFixtures(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return;

                const qualifiedTeams = this.getQualifiedTeams(tournamentId);
                if (qualifiedTeams.length < 2) {
                    console.warn('Not enough qualified teams for knockout stage.');
                    return;
                }

                const knockout = {
                    rounds: [],
                    winnerId: null,
                };

                let currentTeams = qualifiedTeams;
                let roundNumber = 1;
                let roundName = '';

                while (currentTeams.length >= 2) {
                    const numTeams = currentTeams.length;
                    const numMatches = numTeams / 2;
                    const roundMatches = [];
                    const nextRoundTeams = [];
                    const roundId = app.data.generateUniqueId();

                    if (numTeams === 16) roundName = 'Round of 16';
                    else if (numTeams === 8) roundName = 'Quarter-finals';
                    else if (numTeams === 4) roundName = 'Semi-finals';
                    else if (numTeams === 2) roundName = 'Final';
                    else roundName = `Round ${roundNumber}`;

                    let fixtureDate = new Date(Date.now() + (roundNumber * 14 * 24 * 60 * 60 * 1000)); // Two weeks after previous round

                    for (let i = 0; i < numMatches; i++) {
                        const homeTeamId = currentTeams[i].teamId;
                        const awayTeamId = currentTeams[numTeams - 1 - i].teamId; // Seed 1 vs Last, Seed 2 vs Second Last etc.

                        const fixture1 = {
                            id: app.data.generateUniqueId(),
                            tournamentId,
                            date: new Date(fixtureDate.getTime()).toISOString(),
                            homeTeamId: homeTeamId,
                            awayTeamId: awayTeamId,
                            stage: 'knockout',
                            roundId: roundId,
                            leg: 1,
                            status: 'scheduled',
                            score: { home: null, away: null },
                            events: []
                        };
                        app.data.state.fixtures[tournamentId].push(fixture1);
                        roundMatches.push(fixture1.id);

                        if (tournament.mode === 'champions' && numTeams > 2) { // Two-legged ties for CL, except final
                            const fixture2 = {
                                id: app.data.generateUniqueId(),
                                tournamentId,
                                date: new Date(fixtureDate.getTime() + (7 * 24 * 60 * 60 * 1000)).toISOString(), // A week later
                                homeTeamId: awayTeamId, // Swap home/away for second leg
                                awayTeamId: homeTeamId,
                                stage: 'knockout',
                                roundId: roundId,
                                leg: 2,
                                status: 'scheduled',
                                score: { home: null, away: null },
                                events: []
                            };
                            app.data.state.fixtures[tournamentId].push(fixture2);
                            roundMatches.push(fixture2.id);
                        }
                        nextRoundTeams.push({ teamId: null, seed: i + 1 }); // Placeholder for next round
                    }

                    knockout.rounds.push({
                        id: roundId,
                        name: roundName,
                        matches: roundMatches,
                        nextRoundTeams: nextRoundTeams, // Store placeholders for next round
                    });

                    currentTeams = nextRoundTeams; // Update currentTeams for next iteration
                    roundNumber++;
                }

                app.data.state.knockout[tournamentId] = knockout;
                app.data.saveState();
            },

            getQualifiedTeams(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament || !tournament.groups) return [];

                const qualified = [];
                for (const groupId in tournament.groups) {
                    const standings = this.calculateStandings(tournamentId, groupId);
                    // Top 2 teams from each group qualify
                    if (standings.length >= 2) {
                        qualified.push({ teamId: standings[0].teamId, seed: 1, group: groupId });
                        qualified.push({ teamId: standings[1].teamId, seed: 2, group: groupId });
                    }
                }

                // Simple seeding for knockout: Group winners vs Group runners-up
                // A1 vs B2, B1 vs A2, C1 vs D2, D1 vs C2, etc.
                // This is a simplified draw. A real CL draw has more complex rules (country protection, pot seeding).
                qualified.sort((a, b) => {
                    const groupA = a.group.charCodeAt(0);
                    const groupB = b.group.charCodeAt(0);
                    if (groupA !== groupB) return groupA - groupB;
                    return a.seed - b.seed;
                });

                const finalQualified = [];
                const winners = qualified.filter(t => t.seed === 1);
                const runnersUp = qualified.filter(t => t.seed === 2);

                for (let i = 0; i < winners.length; i++) {
                    finalQualified.push(winners[i]);
                    finalQualified.push(runnersUp[(i + 1) % runnersUp.length]); // Simple pairing
                }

                return finalQualified;
            },

            // --- Match Simulation & Result Update ---
            simulateMatch(homeTeamId, awayTeamId) {
                // Simple random score generation, capped to avoid extreme results
                const generateGoals = () => Math.floor(Math.random() * 4); // 0-3 goals
                return {
                    home: generateGoals(),
                    away: generateGoals()
                };
            },

            updateMatchResult(tournamentId, fixtureId, score, events = [], extraTime = null, penalties = null) {
                const tournament = app.data.getTournament(tournamentId);
                const fixture = app.data.getFixture(tournamentId, fixtureId);
                if (!fixture) return;

                // Revert previous stats if match was already played
                if (fixture.status === 'played') {
                    this.revertMatchStats(tournamentId, fixture);
                }

                fixture.score = score;
                fixture.events = events;
                fixture.extraTime = extraTime;
                fixture.penalties = penalties;
                fixture.status = 'played';

                // Determine winner for knockout matches
                if (fixture.stage === 'knockout') {
                    const winnerInfo = this.determineKnockoutWinner(tournamentId, fixture);
                    fixture.winnerId = winnerInfo.winnerId;
                    fixture.loserId = winnerInfo.loserId;
                }

                // Update team and player stats
                this.applyMatchStats(tournamentId, fixture);

                app.data.saveState();
                this.updateKnockoutBracket(tournamentId); // Update bracket if knockout
            },

            revertMatchStats(tournamentId, fixture) {
                const tournament = app.data.getTournament(tournamentId);
                const config = tournament.config;

                const homeTeam = app.data.getTeam(fixture.homeTeamId);
                const awayTeam = app.data.getTeam(fixture.awayTeamId);

                if (!homeTeam || !awayTeam || !fixture.score) return;

                // Revert team stats
                homeTeam.stats.P--;
                awayTeam.stats.P--;

                homeTeam.stats.GF -= fixture.score.home;
                homeTeam.stats.GA -= fixture.score.away;
                homeTeam.stats.GD = homeTeam.stats.GF - homeTeam.stats.GA;

                awayTeam.stats.GF -= fixture.score.away;
                awayTeam.stats.GA -= fixture.score.home;
                awayTeam.stats.GD = awayTeam.stats.GF - awayTeam.stats.GA;

                if (fixture.score.home > fixture.score.away) {
                    homeTeam.stats.W--;
                    awayTeam.stats.L--;
                    homeTeam.stats.Pts -= config.pointsWin;
                } else if (fixture.score.home < fixture.score.away) {
                    homeTeam.stats.L--;
                    awayTeam.stats.W--;
                    awayTeam.stats.Pts -= config.pointsWin;
                } else {
                    homeTeam.stats.D--;
                    awayTeam.stats.D--;
                    homeTeam.stats.Pts -= config.pointsDraw;
                    awayTeam.stats.Pts -= config.pointsDraw;
                }

                // Revert player stats and fair play
                if (fixture.events) {
                    fixture.events.forEach(event => {
                        const player = app.data.getPlayer(event.teamId, event.playerId);
                        if (player) {
                            if (event.type === 'goal') player.stats.goals--;
                            if (event.type === 'assist') player.stats.assists--;
                            if (event.type === 'yellow') {
                                player.stats.yellowCards--;
                                app.data.getTeam(event.teamId).stats.FairPlay--;
                            }
                            if (event.type === 'red') {
                                player.stats.redCards--;
                                app.data.getTeam(event.teamId).stats.FairPlay -= 3; // Red card penalty
                            }
                        }
                        // Revert minutes played (simplified)
                        const teamPlayers = app.data.getPlayersInTeam(event.teamId);
                        teamPlayers.forEach(p => {
                            p.stats.minutes -= (fixture.extraTime ? 120 : 90);
                        });
                    });
                }
            },

            applyMatchStats(tournamentId, fixture) {
                const tournament = app.data.getTournament(tournamentId);
                const config = tournament.config;

                const homeTeam = app.data.getTeam(fixture.homeTeamId);
                const awayTeam = app.data.getTeam(fixture.awayTeamId);

                if (!homeTeam || !awayTeam || !fixture.score) return;

                // Update team stats
                homeTeam.stats.P++;
                awayTeam.stats.P++;

                homeTeam.stats.GF += fixture.score.home;
                homeTeam.stats.GA += fixture.score.away;
                homeTeam.stats.GD = homeTeam.stats.GF - homeTeam.stats.GA;

                awayTeam.stats.GF += fixture.score.away;
                awayTeam.stats.GA += fixture.score.home;
                awayTeam.stats.GD = awayTeam.stats.GF - awayTeam.stats.GA;

                if (fixture.score.home > fixture.score.away) {
                    homeTeam.stats.W++;
                    awayTeam.stats.L++;
                    homeTeam.stats.Pts += config.pointsWin;
                } else if (fixture.score.home < fixture.score.away) {
                    homeTeam.stats.L++;
                    awayTeam.stats.W++;
                    awayTeam.stats.Pts += config.pointsWin;
                } else {
                    homeTeam.stats.D++;
                    awayTeam.stats.D++;
                    homeTeam.stats.Pts += config.pointsDraw;
                    awayTeam.stats.Pts += config.pointsDraw;
                }

                // Update player stats and fair play
                if (fixture.events) {
                    fixture.events.forEach(event => {
                        const player = app.data.getPlayer(event.teamId, event.playerId);
                        if (player) {
                            if (event.type === 'goal') player.stats.goals++;
                            if (event.type === 'assist') {
                                const assistPlayer = app.data.getPlayer(event.teamId, event.assistId);
                                if (assistPlayer) assistPlayer.stats.assists++;
                            }
                            if (event.type === 'yellow') {
                                player.stats.yellowCards++;
                                app.data.getTeam(event.teamId).stats.FairPlay++;
                            }
                            if (event.type === 'red') {
                                player.stats.redCards++;
                                app.data.getTeam(event.teamId).stats.FairPlay += 3; // Red card penalty
                            }
                        }
                    });
                }

                // Update minutes played (simplified: all players on roster get minutes)
                const minutesPlayed = fixture.extraTime ? 120 : 90;
                const homePlayers = app.data.getPlayersInTeam(fixture.homeTeamId);
                homePlayers.forEach(p => p.stats.minutes += minutesPlayed);
                const awayPlayers = app.data.getPlayersInTeam(fixture.awayTeamId);
                awayPlayers.forEach(p => p.stats.minutes += minutesPlayed);
            },

            determineKnockoutWinner(tournamentId, fixture) {
                const tournament = app.data.getTournament(tournamentId);
                const knockout = app.data.getKnockout(tournamentId);
                const config = tournament.config;

                let homeTotalGoals = fixture.score.home;
                let awayTotalGoals = fixture.score.away;
                let homeAwayGoals = 0;
                let awayAwayGoals = 0;

                if (fixture.extraTime) {
                    homeTotalGoals += fixture.extraTime.home;
                    awayTotalGoals += fixture.extraTime.away;
                }

                let winnerId = null;
                let loserId = null;

                if (tournament.mode === 'champions' && fixture.leg) {
                    // For Champions League, need to consider aggregate score over two legs
                    const roundMatches = knockout.rounds.find(r => r.id === fixture.roundId).matches;
                    const otherLegFixture = app.data.getFixture(tournamentId, roundMatches.find(mId => mId !== fixture.id));

                    if (otherLegFixture && otherLegFixture.status === 'played') {
                        const firstLeg = fixture.leg === 1 ? fixture : otherLegFixture;
                        const secondLeg = fixture.leg === 2 ? fixture : otherLegFixture;

                        const aggHomeGoals = (firstLeg.homeTeamId === fixture.homeTeamId ? firstLeg.score.home : firstLeg.score.away) +
                                             (secondLeg.homeTeamId === fixture.homeTeamId ? secondLeg.score.home : secondLeg.score.away);
                        const aggAwayGoals = (firstLeg.homeTeamId === fixture.awayTeamId ? firstLeg.score.home : firstLeg.score.away) +
                                             (secondLeg.homeTeamId === fixture.awayTeamId ? secondLeg.score.home : secondLeg.score.away);

                        const firstLegHomeAwayGoals = firstLeg.homeTeamId === fixture.homeTeamId ? firstLeg.score.away : firstLeg.score.home;
                        const secondLegHomeAwayGoals = secondLeg.homeTeamId === fixture.homeTeamId ? secondLeg.score.away : secondLeg.score.home;

                        const aggHomeAwayGoals = (firstLeg.homeTeamId === fixture.homeTeamId ? firstLeg.score.away : firstLeg.score.home) +
                                                 (secondLeg.homeTeamId === fixture.homeTeamId ? secondLeg.score.away : secondLeg.score.home);
                        const aggAwayAwayGoals = (firstLeg.homeTeamId === fixture.awayTeamId ? firstLeg.score.away : firstLeg.score.home) +
                                                 (secondLeg.homeTeamId === fixture.awayTeamId ? secondLeg.score.away : secondLeg.score.home);

                        if (aggHomeGoals > aggAwayGoals) {
                            winnerId = fixture.homeTeamId;
                            loserId = fixture.awayTeamId;
                        } else if (aggHomeGoals < aggAwayGoals) {
                            winnerId = fixture.awayTeamId;
                            loserId = fixture.homeTeamId;
                        } else { // Aggregate score is tied
                            if (config.awayGoalsRuleEnabled) {
                                // Away goals rule: team with more away goals wins
                                if (aggHomeAwayGoals > aggAwayAwayGoals) { // Home team scored more away goals
                                    winnerId = fixture.homeTeamId;
                                    loserId = fixture.awayTeamId;
                                } else if (aggHomeAwayGoals < aggAwayAwayGoals) { // Away team scored more away goals
                                    winnerId = fixture.awayTeamId;
                                    loserId = fixture.homeTeamId;
                                }
                            }

                            if (!winnerId) { // Still tied after away goals or rule disabled
                                if (fixture.penalties) {
                                    if (fixture.penalties.home > fixture.penalties.away) {
                                        winnerId = fixture.homeTeamId;
                                        loserId = fixture.awayTeamId;
                                    } else {
                                        winnerId = fixture.awayTeamId;
                                        loserId = fixture.homeTeamId;
                                    }
                                }
                            }
                        }
                    }
                } else { // World Cup (single leg) or Champions League Final
                    if (homeTotalGoals > awayTotalGoals) {
                        winnerId = fixture.homeTeamId;
                        loserId = fixture.awayTeamId;
                    } else if (homeTotalGoals < awayTotalGoals) {
                        winnerId = fixture.awayTeamId;
                        loserId = fixture.homeTeamId;
                    } else { // Tied after regular/extra time
                        if (fixture.penalties) {
                            if (fixture.penalties.home > fixture.penalties.away) {
                                winnerId = fixture.homeTeamId;
                                loserId = fixture.awayTeamId;
                            } else {
                                winnerId = fixture.awayTeamId;
                                loserId = fixture.homeTeamId;
                            }
                        }
                    }
                }
                return { winnerId, loserId };
            },

            getAggregateScore(tournamentId, team1Id, team2Id, roundId) {
                const tournament = app.data.getTournament(tournamentId);
                const knockout = app.data.getKnockout(tournamentId);
                if (!tournament || !knockout) return null;

                const round = knockout.rounds.find(r => r.id === roundId);
                if (!round) return null;

                let team1Goals = 0;
                let team2Goals = 0;
                let team1AwayGoals = 0;
                let team2AwayGoals = 0;
                let allMatchesPlayed = true;

                round.matches.forEach(matchId => {
                    const fixture = app.data.getFixture(tournamentId, matchId);
                    if (!fixture || fixture.status !== 'played') {
                        allMatchesPlayed = false;
                        return;
                    }

                    if ((fixture.homeTeamId === team1Id && fixture.awayTeamId === team2Id) ||
                        (fixture.homeTeamId === team2Id && fixture.awayTeamId === team1Id)) {

                        if (fixture.homeTeamId === team1Id) {
                            team1Goals += fixture.score.home;
                            team2Goals += fixture.score.away;
                            team1AwayGoals += fixture.score.away; // Team 1 scored away
                            team2AwayGoals += fixture.score.home; // Team 2 scored away
                        } else { // fixture.homeTeamId === team2Id
                            team1Goals += fixture.score.away;
                            team2Goals += fixture.score.home;
                            team1AwayGoals += fixture.score.home; // Team 1 scored away
                            team2AwayGoals += fixture.score.away; // Team 2 scored away
                        }

                        if (fixture.extraTime) {
                            if (fixture.homeTeamId === team1Id) {
                                team1Goals += fixture.extraTime.home;
                                team2Goals += fixture.extraTime.away;
                            } else {
                                team1Goals += fixture.extraTime.away;
                                team2Goals += fixture.extraTime.home;
                            }
                        }
                    }
                });

                if (!allMatchesPlayed) return null; // Only calculate aggregate if both legs are played

                let winnerId = null;
                let loserId = null;

                if (team1Goals > team2Goals) {
                    winnerId = team1Id;
                    loserId = team2Id;
                } else if (team1Goals < team2Goals) {
                    winnerId = team2Id;
                    loserId = team1Id;
                } else { // Aggregate tied
                    if (tournament.config.awayGoalsRuleEnabled) {
                        if (team1AwayGoals > team2AwayGoals) {
                            winnerId = team1Id;
                            loserId = team2Id;
                        } else if (team1AwayGoals < team2AwayGoals) {
                            winnerId = team2Id;
                            loserId = team1Id;
                        }
                    }
                    // If still tied, winner is determined by penalties in the second leg
                    const secondLegFixture = round.matches.map(id => app.data.getFixture(tournamentId, id)).find(f => f.leg === 2);
                    if (secondLegFixture && secondLegFixture.penalties) {
                        if (secondLegFixture.penalties.home > secondLegFixture.penalties.away) {
                            winnerId = secondLegFixture.homeTeamId;
                            loserId = secondLegFixture.awayTeamId;
                        } else {
                            winnerId = secondLegFixture.awayTeamId;
                            loserId = secondLegFixture.homeTeamId;
                        }
                    }
                }

                return {
                    home: team1Goals,
                    away: team2Goals,
                    awayGoalsHomeTeam: team1AwayGoals,
                    awayGoalsAwayTeam: team2AwayGoals,
                    winnerId,
                    loserId
                };
            },

            updateKnockoutBracket(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                const knockout = app.data.getKnockout(tournamentId);
                if (!tournament || !knockout) return;

                let changed = false;
                for (let i = 0; i < knockout.rounds.length; i++) {
                    const round = knockout.rounds[i];
                    const nextRound = knockout.rounds[i + 1];

                    let allMatchesPlayedInRound = true;
                    const roundWinners = [];

                    for (let j = 0; j < round.matches.length; j++) {
                        const fixture = app.data.getFixture(tournamentId, round.matches[j]);
                        if (!fixture || fixture.status !== 'played') {
                            allMatchesPlayedInRound = false;
                            break;
                        }
                        if (fixture.winnerId) {
                            roundWinners.push(fixture.winnerId);
                        }
                    }

                    if (allMatchesPlayedInRound && nextRound) {
                        // Populate next round's teams
                        const uniqueWinners = [...new Set(roundWinners)]; // Ensure unique winners for two-legged ties
                        if (uniqueWinners.length === nextRound.nextRoundTeams.length) {
                            uniqueWinners.forEach((winnerId, index) => {
                                if (nextRound.nextRoundTeams[index].teamId !== winnerId) {
                                    nextRound.nextRoundTeams[index].teamId = winnerId;
                                    changed = true;
                                }
                            });
                        }

                        // If next round's teams are all set, generate its fixtures if not already
                        const nextRoundTeamsReady = nextRound.nextRoundTeams.every(t => t.teamId !== null);
                        const nextRoundFixturesExist = nextRound.matches.length > 0;

                        if (nextRoundTeamsReady && !nextRoundFixturesExist) {
                            const nextRoundFixtureDate = new Date(Date.now() + ((i + 2) * 14 * 24 * 60 * 60 * 1000));
                            const numMatches = nextRound.nextRoundTeams.length / 2;
                            for (let k = 0; k < numMatches; k++) {
                                const homeTeamId = nextRound.nextRoundTeams[k].teamId;
                                const awayTeamId = nextRound.nextRoundTeams[nextRound.nextRoundTeams.length - 1 - k].teamId;

                                const fixture1 = {
                                    id: app.data.generateUniqueId(),
                                    tournamentId,
                                    date: new Date(nextRoundFixtureDate.getTime()).toISOString(),
                                    homeTeamId: homeTeamId,
                                    awayTeamId: awayTeamId,
                                    stage: 'knockout',
                                    roundId: nextRound.id,
                                    leg: 1,
                                    status: 'scheduled',
                                    score: { home: null, away: null },
                                    events: []
                                };
                                app.data.state.fixtures[tournamentId].push(fixture1);
                                nextRound.matches.push(fixture1.id);

                                if (tournament.mode === 'champions' && nextRound.nextRoundTeams.length > 2) {
                                    const fixture2 = {
                                        id: app.data.generateUniqueId(),
                                        tournamentId,
                                        date: new Date(nextRoundFixtureDate.getTime() + (7 * 24 * 60 * 60 * 1000)).toISOString(),
                                        homeTeamId: awayTeamId,
                                        awayTeamId: homeTeamId,
                                        stage: 'knockout',
                                        roundId: nextRound.id,
                                        leg: 2,
                                        status: 'scheduled',
                                        score: { home: null, away: null },
                                        events: []
                                    };
                                    app.data.state.fixtures[tournamentId].push(fixture2);
                                    nextRound.matches.push(fixture2.id);
                                }
                            }
                            changed = true;
                        }
                    } else if (allMatchesPlayedInRound && !nextRound && round.matches.length === 1) {
                        // Final round, determine tournament winner
                        const finalFixture = app.data.getFixture(tournamentId, round.matches[0]);
                        if (finalFixture && finalFixture.winnerId && knockout.winnerId !== finalFixture.winnerId) {
                            knockout.winnerId = finalFixture.winnerId;
                            changed = true;
                        }
                    }
                }

                if (changed) {
                    app.data.saveState();
                    app.ui.renderKnockoutBracket(); // Re-render the bracket
                }
            },

            // --- Standings Calculation ---
            calculateStandings(tournamentId, groupId = null) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return [];

                const teamsInScope = groupId
                    ? tournament.groups[groupId].map(id => app.data.getTeam(id))
                    : app.data.getTeamsInTournament(tournamentId);

                const teamStatsMap = {};
                teamsInScope.forEach(team => {
                    teamStatsMap[team.id] = {
                        teamId: team.id,
                        P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0, FairPlay: 0,
                        // For head-to-head tie-breaker
                        h2hMatches: {}, // { opponentId: { homeScore, awayScore, homeTeamId, awayTeamId } }
                        h2hPoints: 0,
                        h2hGF: 0,
                        h2hGA: 0,
                        h2hGD: 0,
                    };
                });

                const fixtures = app.data.getFixtures(tournamentId).filter(f => f.status === 'played');
                const relevantFixtures = fixtures.filter(f => {
                    const isRelevantGroup = groupId ? f.groupId === groupId : f.stage === 'league';
                    const involvesTeamsInScope = teamsInScope.some(t => t.id === f.homeTeamId || t.id === f.awayTeamId);
                    return isRelevantGroup && involvesTeamsInScope;
                });

                relevantFixtures.forEach(fixture => {
                    const homeStats = teamStatsMap[fixture.homeTeamId];
                    const awayStats = teamStatsMap[fixture.awayTeamId];

                    if (!homeStats || !awayStats) return; // Skip if teams are not in current scope

                    homeStats.P++;
                    awayStats.P++;

                    homeStats.GF += fixture.score.home;
                    homeStats.GA += fixture.score.away;
                    awayStats.GF += fixture.score.away;
                    awayStats.GA += fixture.score.home;

                    if (fixture.score.home > fixture.score.away) {
                        homeStats.W++;
                        awayStats.L++;
                        homeStats.Pts += tournament.config.pointsWin;
                    } else if (fixture.score.home < fixture.score.away) {
                        homeStats.L++;
                        awayStats.W++;
                        awayStats.Pts += tournament.config.pointsWin;
                    } else {
                        homeStats.D++;
                        awayStats.D++;
                        homeStats.Pts += tournament.config.pointsDraw;
                        awayStats.Pts += tournament.config.pointsDraw;
                    }

                    // Store head-to-head match results
                    homeStats.h2hMatches[fixture.awayTeamId] = fixture;
                    awayStats.h2hMatches[fixture.homeTeamId] = fixture;

                    // Update Fair Play (simplified: sum of cards)
                    fixture.events?.forEach(event => {
                        if (event.type === 'yellow') teamStatsMap[event.teamId].FairPlay += 1;
                        if (event.type === 'red') teamStatsMap[event.teamId].FairPlay += 3; // Red card counts as 3 yellow cards
                    });
                });

                // Calculate GD after all matches
                teamsInScope.forEach(team => {
                    if (teamStatsMap[team.id]) {
                        teamStatsMap[team.id].GD = teamStatsMap[team.id].GF - teamStatsMap[team.id].GA;
                    }
                });

                let standingsArray = Object.values(teamStatsMap);

                // Apply tie-breakers
                const tieBreakerOrder = tournament.config.tieBreakerOrder || ['points', 'goalDifference', 'goalsFor', 'headToHeadPoints', 'headToHeadGoalDifference', 'fairPlay', 'alphabetical'];

                standingsArray.sort((a, b) => {
                    for (const breaker of tieBreakerOrder) {
                        let comparison = 0;
                        switch (breaker) {
                            case 'points':
                                comparison = b.Pts - a.Pts;
                                break;
                            case 'goalDifference':
                                comparison = b.GD - a.GD;
                                break;
                            case 'goalsFor':
                                comparison = b.GF - a.GF;
                                break;
                            case 'headToHeadPoints':
                                comparison = this.compareHeadToHead(a, b, 'Pts', teamsInScope);
                                break;
                            case 'headToHeadGoalDifference':
                                comparison = this.compareHeadToHead(a, b, 'GD', teamsInScope);
                                break;
                            case 'fairPlay':
                                comparison = a.FairPlay - b.FairPlay; // Lower is better
                                break;
                            case 'alphabetical':
                                const teamA = app.data.getTeam(a.teamId);
                                const teamB = app.data.getTeam(b.teamId);
                                comparison = teamA.name.localeCompare(teamB.name);
                                break;
                        }
                        if (comparison !== 0) return comparison;
                    }
                    return 0; // Still tied
                });

                // Store standings in app.data.state
                if (!app.data.state.standings[tournamentId]) {
                    app.data.state.standings[tournamentId] = {};
                }
                if (groupId) {
                    app.data.state.standings[tournamentId][groupId] = standingsArray;
                } else {
                    app.data.state.standings[tournamentId].main = standingsArray;
                }

                return standingsArray;
            },

            compareHeadToHead(teamAStats, teamBStats, statKey, allTeamsInScope) {
                // Only apply H2H if both teams are part of the same tied group
                // and have played each other.
                const teamAId = teamAStats.teamId;
                const teamBId = teamBStats.teamId;

                const h2hFixtures = app.data.getFixtures(app.data.currentTournamentId)
                    .filter(f => f.status === 'played' &&
                                  ((f.homeTeamId === teamAId && f.awayTeamId === teamBId) ||
                                   (f.homeTeamId === teamBId && f.awayTeamId === teamAId)));

                if (h2hFixtures.length === 0) return 0; // No head-to-head matches

                let h2hA = { Pts: 0, GF: 0, GA: 0, GD: 0 };
                let h2hB = { Pts: 0, GF: 0, GA: 0, GD: 0 };

                h2hFixtures.forEach(f => {
                    const config = app.data.getTournament(app.data.currentTournamentId).config;
                    if (f.homeTeamId === teamAId) {
                        h2hA.GF += f.score.home;
                        h2hA.GA += f.score.away;
                        h2hB.GF += f.score.away;
                        h2hB.GA += f.score.home;
                        if (f.score.home > f.score.away) h2hA.Pts += config.pointsWin;
                        else if (f.score.home < f.score.away) h2hB.Pts += config.pointsWin;
                        else { h2hA.Pts += config.pointsDraw; h2hB.Pts += config.pointsDraw; }
                    } else { // f.homeTeamId === teamBId
                        h2hB.GF += f.score.home;
                        h2hB.GA += f.score.away;
                        h2hA.GF += f.score.away;
                        h2hA.GA += f.score.home;
                        if (f.score.home > f.score.away) h2hB.Pts += config.pointsWin;
                        else if (f.score.home < f.score.away) h2hA.Pts += config.pointsWin;
                        else { h2hA.Pts += config.pointsDraw; h2hB.Pts += config.pointsDraw; }
                    }
                });

                h2hA.GD = h2hA.GF - h2hA.GA;
                h2hB.GD = h2hB.GF - h2hB.GA;

                if (statKey === 'Pts') return h2hB.Pts - h2hA.Pts;
                if (statKey === 'GD') return h2hB.GD - h2hA.GD;
                if (statKey === 'GF') return h2hB.GF - h2hA.GF;

                return 0;
            },

            getAllPlayersWithStats(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return [];

                const allPlayers = [];
                tournament.teams.forEach(teamId => {
                    const players = app.data.getPlayersInTeam(teamId);
                    allPlayers.push(...players);
                });
                return allPlayers;
            },

            exportStandingsAsCsv(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return;

                let csvContent = '';
                let filename = `${tournament.name}_Standings.csv`;

                if (tournament.mode === 'league') {
                    const standings = this.calculateStandings(tournamentId);
                    csvContent += this.generateCsvTable(standings, 'League Standings');
                } else {
                    if (!tournament.groups) {
                        alert('No groups drawn to export standings.');
                        return;
                    }
                    for (const groupId in tournament.groups) {
                        const groupStandings = this.calculateStandings(tournamentId, groupId);
                        csvContent += this.generateCsvTable(groupStandings, `Group ${groupId} Standings`);
                        csvContent += '\n\n'; // Separator between groups
                    }
                    filename = `${tournament.name}_Group_Standings.csv`;
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                if (link.download !== undefined) { // Feature detection
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', filename);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else {
                    alert('Your browser does not support downloading files directly. Please copy the content manually.');
                    console.log(csvContent);
                }
            },

            generateCsvTable(standings, title) {
                let csv = `${title}\n`;
                const headers = ['Pos', 'Team', 'P', 'W', 'D', 'L', 'GF', 'GA', 'GD', 'Pts', 'FairPlay'];
                csv += headers.join(',') + '\n';

                standings.forEach((teamStats, index) => {
                    const team = app.data.getTeam(teamStats.teamId);
                    const row = [
                        index + 1,
                        `"${team ? team.name.replace(/"/g, '""') : 'Unknown'}"`, // Handle commas in names
                        teamStats.P,
                        teamStats.W,
                        teamStats.D,
                        teamStats.L,
                        teamStats.GF,
                        teamStats.GA,
                        teamStats.GD,
                        teamStats.Pts,
                        teamStats.FairPlay
                    ];
                    csv += row.join(',') + '\n';
                });
                return csv;
            },

            simulateAllRemainingFixtures(tournamentId) {
                const tournament = app.data.getTournament(tournamentId);
                if (!tournament) return;

                const fixtures = app.data.getFixtures(tournamentId);
                const scheduledFixtures = fixtures.filter(f => f.status === 'scheduled');

                scheduledFixtures.forEach(fixture => {
                    const simulatedScore = this.simulateMatch(fixture.homeTeamId, fixture.awayTeamId);
                    let extraTime = null;
                    let penalties = null;

                    if (fixture.stage === 'knockout' && simulatedScore.home === simulatedScore.away) {
                        // Simulate extra time
                        const etScore = this.simulateMatch(fixture.homeTeamId, fixture.awayTeamId);
                        extraTime = etScore;
                        if (etScore.home === etScore.away) {
                            // Simulate penalties
                            penalties = {
                                home: Math.floor(Math.random() * 5) + 1, // 1-5 penalties
                                away: Math.floor(Math.random() * 5) + 1
                            };
                            while (penalties.home === penalties.away) { // Ensure a winner
                                penalties.away = Math.floor(Math.random() * 5) + 1;
                            }
                        }
                    }
                    this.updateMatchResult(tournamentId, fixture.id, simulatedScore, [], extraTime, penalties);
                });
                app.data.saveState();
            },

            // --- Demo Data Seeding ---
            seedDemoData() {
                // Clear existing data first
                app.data.state = {
                    tournaments: [],
                    teams: {},
                    players: {},
                    fixtures: {},
                    standings: {},
                    knockout: {},
                };
                app.data.uniqueIdCounter = 0;

                // Seed League Tournament
                const leagueTeamsData = [
                    { name: 'Manchester Utd', shortName: 'MUN', country: 'England', primaryColor: '#DA291C', secondaryColor: '#FBE122' },
                    { name: 'Liverpool FC', shortName: 'LIV', country: 'England', primaryColor: '#C8102E', secondaryColor: '#00B2A9' },
                    { name: 'Arsenal FC', shortName: 'ARS', country: 'England', primaryColor: '#EF0107', secondaryColor: '#005792' },
                    { name: 'Chelsea FC', shortName: 'CHE', country: 'England', primaryColor: '#034694', secondaryColor: '#6A7AB5' },
                    { name: 'Tottenham Hotspur', shortName: 'TOT', country: 'England', primaryColor: '#132257', secondaryColor: '#FFFFFF' },
                    { name: 'Manchester City', shortName: 'MCI', country: 'England', primaryColor: '#6CABDD', secondaryColor: '#1C2C5B' },
                    { name: 'Newcastle Utd', shortName: 'NEW', country: 'England', primaryColor: '#241F20', secondaryColor: '#FFFFFF' },
                    { name: 'Aston Villa', shortName: 'AVL', country: 'England', primaryColor: '#410E2B', secondaryColor: '#95BFE5' },
                    { name: 'Everton FC', shortName: 'EVE', country: 'England', primaryColor: '#003399', secondaryColor: '#FFFFFF' },
                    { name: 'West Ham Utd', shortName: 'WHU', country: 'England', primaryColor: '#7A263A', secondaryColor: '#1BB1E7' },
                ];
                const leaguePlayersData = {
                    'MUN': [{ name: 'Rashford', number: 10, position: 'FW' }, { name: 'Fernandes', number: 8, position: 'MF' }, { name: 'Onana', number: 24, position: 'GK' }],
                    'LIV': [{ name: 'Salah', number: 11, position: 'FW' }, { name: 'Van Dijk', number: 4, position: 'DF' }, { name: 'Alisson', number: 1, position: 'GK' }],
                    'ARS': [{ name: 'Saka', number: 7, position: 'FW' }, { name: 'Odegaard', number: 8, position: 'MF' }, { name: 'Ramsdale', number: 1, position: 'GK' }],
                    'CHE': [{ name: 'Sterling', number: 7, position: 'FW' }, { name: 'Enzo', number: 8, position: 'MF' }, { name: 'Sanchez', number: 1, position: 'GK' }],
                    'TOT': [{ name: 'Son', number: 7, position: 'FW' }, { name: 'Maddison', number: 10, position: 'MF' }, { name: 'Vicario', number: 13, position: 'GK' }],
                    'MCI': [{ name: 'Haaland', number: 9, position: 'FW' }, { name: 'De Bruyne', number: 17, position: 'MF' }, { name: 'Ederson', number: 31, position: 'GK' }],
                    'NEW': [{ name: 'Isak', number: 14, position: 'FW' }, { name: 'Guimaraes', number: 39, position: 'MF' }, { name: 'Pope', number: 22, position: 'GK' }],
                    'AVL': [{ name: 'Watkins', number: 11, position: 'FW' }, { name: 'McGinn', number: 7, position: 'MF' }, { name: 'Martinez', number: 1, position: 'GK' }],
                    'EVE': [{ name: 'Calvert-Lewin', number: 9, position: 'FW' }, { name: 'Doucoure', number: 16, position: 'MF' }, { name: 'Pickford', number: 1, position: 'GK' }],
                    'WHU': [{ name: 'Bowen', number: 20, position: 'FW' }, { name: 'Paqueta', number: 10, position: 'MF' }, { name: 'Areola', number: 23, position: 'GK' }],
                };
                const leagueTournament = this.createTournament('Premier League 2024/25', 'league');
                leagueTeamsData.forEach(teamData => {
                    const teamId = app.data.generateUniqueId();
                    app.data.state.teams[teamId] = { id: teamId, ...teamData, stats: { P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0, FairPlay: 0 } };
                    leagueTournament.teams.push(teamId);
                    app.data.state.players[teamId] = (leaguePlayersData[teamData.shortName] || []).map(p => ({ id: app.data.generateUniqueId(), teamId, ...p, stats: { goals: 0, assists: 0, yellowCards: 0, redCards: 0, minutes: 0 } }));
                });
                this.generateFixtures(leagueTournament.id);
                this.simulateAllRemainingFixtures(leagueTournament.id); // Simulate all for demo

                // Seed Champions League Tournament
                const clTeamsData = [
                    { name: 'Real Madrid', shortName: 'RMA', country: 'Spain', primaryColor: '#FFFFFF', secondaryColor: '#000000' },
                    { name: 'FC Barcelona', shortName: 'BAR', country: 'Spain', primaryColor: '#A50044', secondaryColor: '#004D98' },
                    { name: 'Bayern Munich', shortName: 'BAY', country: 'Germany', primaryColor: '#DC052D', secondaryColor: '#FFFFFF' },
                    { name: 'Borussia Dortmund', shortName: 'BVB', country: 'Germany', primaryColor: '#FDE100', secondaryColor: '#000000' },
                    { name: 'Paris SG', shortName: 'PSG', country: 'France', primaryColor: '#004170', secondaryColor: '#DA291C' },
                    { name: 'Juventus FC', shortName: 'JUV', country: 'Italy', primaryColor: '#000000', secondaryColor: '#FFFFFF' },
                    { name: 'Inter Milan', shortName: 'INT', country: 'Italy', primaryColor: '#000000', secondaryColor: '#0070B8' },
                    { name: 'AC Milan', shortName: 'ACM', country: 'Italy', primaryColor: '#FB090B', secondaryColor: '#000000' },
                    { name: 'Man City', shortName: 'MCI', country: 'England', primaryColor: '#6CABDD', secondaryColor: '#1C2C5B' },
                    { name: 'Liverpool FC', shortName: 'LIV', country: 'England', primaryColor: '#C8102E', secondaryColor: '#00B2A9' },
                    { name: 'Ajax', shortName: 'AJX', country: 'Netherlands', primaryColor: '#D2122E', secondaryColor: '#FFFFFF' },
                    { name: 'Porto', shortName: 'POR', country: 'Portugal', primaryColor: '#004288', secondaryColor: '#FFFFFF' },
                    { name: 'Benfica', shortName: 'BEN', country: 'Portugal', primaryColor: '#ED1C24', secondaryColor: '#FFFFFF' },
                    { name: 'Atletico Madrid', shortName: 'ATM', country: 'Spain', primaryColor: '#CB3524', secondaryColor: '#FFFFFF' },
                    { name: 'RB Leipzig', shortName: 'RBL', country: 'Germany', primaryColor: '#002D62', secondaryColor: '#FFFFFF' },
                    { name: 'Napoli', shortName: 'NAP', country: 'Italy', primaryColor: '#008CFF', secondaryColor: '#FFFFFF' },
                ];
                const clTournament = this.createTournament('Champions League 2024/25', 'champions');
                clTeamsData.forEach(teamData => {
                    const teamId = app.data.generateUniqueId();
                    app.data.state.teams[teamId] = { id: teamId, ...teamData, stats: { P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0, FairPlay: 0 } };
                    clTournament.teams.push(teamId);
                    app.data.state.players[teamId] = [{ id: app.data.generateUniqueId(), teamId, name: `${teamData.shortName} Star`, number: 9, position: 'FW', stats: { goals: 0, assists: 0, yellowCards: 0, redCards: 0, minutes: 0 } }];
                });
                this.drawGroups(clTournament.id);
                this.generateFixtures(clTournament.id);
                this.simulateAllRemainingFixtures(clTournament.id);
                this.generateKnockoutFixtures(clTournament.id); // Generate knockout after group stage is "played"
                this.simulateAllRemainingFixtures(clTournament.id); // Simulate knockout matches

                // Seed World Cup Tournament
                const wcTeamsData = [
                    { name: 'Brazil', shortName: 'BRA', country: 'Brazil', primaryColor: '#009B3A', secondaryColor: '#FFDD00' },
                    { name: 'Argentina', shortName: 'ARG', country: 'Argentina', primaryColor: '#74ACDF', secondaryColor: '#FFFFFF' },
                    { name: 'France', shortName: 'FRA', country: 'France', primaryColor: '#002395', secondaryColor: '#ED2939' },
                    { name: 'Germany', shortName: 'GER', country: 'Germany', primaryColor: '#000000', secondaryColor: '#DD0000' },
                    { name: 'Spain', shortName: 'ESP', country: 'Spain', primaryColor: '#AA151B', secondaryColor: '#F1BF00' },
                    { name: 'England', shortName: 'ENG', country: 'England', primaryColor: '#FFFFFF', secondaryColor: '#C8102E' },
                    { name: 'Portugal', shortName: 'POR', country: 'Portugal', primaryColor: '#046A38', secondaryColor: '#DA291C' },
                    { name: 'Italy', shortName: 'ITA', country: 'Italy', primaryColor: '#008C45', secondaryColor: '#FFFFFF' },
                    { name: 'Netherlands', shortName: 'NED', country: 'Netherlands', primaryColor: '#FF3C00', secondaryColor: '#FFFFFF' },
                    { name: 'Belgium', shortName: 'BEL', country: 'Belgium', primaryColor: '#FDDA24', secondaryColor: '#EF3340' },
                    { name: 'USA', shortName: 'USA', country: 'USA', primaryColor: '#002868', secondaryColor: '#BF0A30' },
                    { name: 'Mexico', shortName: 'MEX', country: 'Mexico', primaryColor: '#006847', secondaryColor: '#C8102E' },
                    { name: 'Japan', shortName: 'JPN', country: 'Japan', primaryColor: '#000080', secondaryColor: '#BC002D' },
                    { name: 'South Korea', shortName: 'KOR', country: 'South Korea', primaryColor: '#C8102E', secondaryColor: '#000080' },
                    { name: 'Australia', shortName: 'AUS', country: 'Australia', primaryColor: '#00843D', secondaryColor: '#FFCD00' },
                    { name: 'Canada', shortName: 'CAN', country: 'Canada', primaryColor: '#FF0000', secondaryColor: '#FFFFFF' },
                ];
                const wcTournament = this.createTournament('World Cup 2026', 'worldcup');
                wcTeamsData.forEach(teamData => {
                    const teamId = app.data.generateUniqueId();
                    app.data.state.teams[teamId] = { id: teamId, ...teamData, stats: { P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0, FairPlay: 0 } };
                    wcTournament.teams.push(teamId);
                    app.data.state.players[teamId] = [{ id: app.data.generateUniqueId(), teamId, name: `${teamData.shortName} Hero`, number: 10, position: 'FW', stats: { goals: 0, assists: 0, yellowCards: 0, redCards: 0, minutes: 0 } }];
                });
                this.drawGroups(wcTournament.id);
                this.generateFixtures(wcTournament.id);
                this.simulateAllRemainingFixtures(wcTournament.id);
                this.generateKnockoutFixtures(wcTournament.id);
                this.simulateAllRemainingFixtures(wcTournament.id);

                app.data.saveState();
                alert('Demo data seeded successfully!');
            }
        };

        // --- Initialize Application ---
        document.addEventListener('DOMContentLoaded', () => {
            app.ui.init();
            app.logic.init();

            if (!app.data.loadState()) {
                app.logic.seedDemoData();
            }
            app.ui.renderSidebar();
            app.ui.showHomeView();
        });
    </script>
</body>
</html>
